<!-- Copyright © 2025 Joshua Harding. All rights reserved -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bhop</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Spice&display=swap" rel="stylesheet">
    <style>
        * { padding: 0; margin: 0; box-sizing: border-box; }
        html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; background: black; background-color: black; font-family: sans-serif; }
        #ui-scale-wrapper { position: absolute; width: 1920px; height: 1080px; top: 50%; left: 50%; transform-origin: center center; z-index: 114004827; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        button { position: relative; width: 11em; height: 4em; outline: none; transition: 0.3s; background-color: transparent; border: none; font-size: 19px; font-weight: bold; color: #ddebf0; font-family: inherit; margin: 1em 0; cursor: pointer;}
        #clip { --color: #2761c3; position: absolute; top: 0; overflow: hidden; width: 100%; height: 100%; border: 5px double var(--color); box-shadow: inset 0px 0px 15px #195480; -webkit-clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
        .arrow { position: absolute; transition: 0.2s; background-color: #2761c3; top: 35%; width: 11%; height: 30%; }
        #leftArrow { left: -13.5%; -webkit-clip-path: polygon(100% 0, 100% 100%, 0 50%); clip-path: polygon(100% 0, 100% 100%, 0 50%); }
        #rightArrow { -webkit-clip-path: polygon(100% 49%, 0 0, 0 100%); clip-path: polygon(100% 49%, 0 0, 0 100%); left: 102%; }
        button:hover #rightArrow { background-color: #27c39f; left: -15%; animation: 0.6s ease-in-out both infinite alternate rightArrow8; }
        button:hover #leftArrow { background-color: #27c39f; left: 103%; animation: 0.6s ease-in-out both infinite alternate leftArrow8; }
        .corner { position: absolute; width: 4em; height: 4em; background-color: #2761c3; box-shadow: inset 1px 1px 8px #2781c3; transform: scale(1) rotate(45deg); transition: 0.2s; }
        #rightTop { top: -1.98em; left: 91%; }
        #leftTop { top: -1.96em; left: -3.0em; }
        #leftBottom { top: 2.10em; left: -2.15em; }
        #rightBottom { top: 45%; left: 88%; }
        button:hover #leftTop { animation: 0.1s ease-in-out 0.05s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover #rightTop { animation: 0.1s ease-in-out 0.15s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover #rightBottom { animation: 0.1s ease-in-out 0.25s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover #leftBottom { animation: 0.1s ease-in-out 0.35s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover .corner { transform: scale(1.25) rotate(45deg); }
        button:hover #clip { animation: 0.2s ease-in-out 0.55s both greenLight8; --color: #27c39f; }
        @keyframes changeColor8 { from { background-color: #2781c3; } to { background-color: #27c39f; } }
        @keyframes lightEffect8 {from { box-shadow: 1px 1px 5px #27c39f; } to { box-shadow: 0 0 2px #27c39f; } }
        @keyframes greenLight8 { from {} to { box-shadow: inset 0px 0px 32px #27c39f; } }
        @keyframes leftArrow8 { from { transform: translate(0px); } to { transform: translateX(10px); } }
        @keyframes rightArrow8 { from { transform: translate(0px); } to { transform: translateX(-10px); } }
        .btn { display: none; justify-content: center; align-items: center; width: 13rem; overflow: hidden; height: 3rem; margin: 2em; transform: translateY(4em); transition: transform 0.5s; background-size: 300% 300%; cursor: pointer; backdrop-filter: blur(1rem); border-radius: 5rem; transition: 0.5s; animation: gradient_301 5s ease infinite; border: double 4px transparent; background-image: linear-gradient(#212121, #212121), linear-gradient( 137.48deg, #ffdb3b 10%, #fe53bb 45%, #8f51ea 67%, #0044ff 87% ); background-origin: border-box; background-clip: content-box, border-box; }
        #container-stars { position: absolute; margin-top: -2.1em; z-index: -1; width: 100%; height: 100%; overflow: hidden; transition: 114004827s; backdrop-filter: blur(1rem); border-radius: 5rem; }
        strong { z-index: 2; font-family: "Avalors Personal Use"; font-size: 12px; letter-spacing: 5px; color: #ffffff; text-shadow: 0 0 4px white; }
        #glow { position: absolute; display: flex; width: 12rem; }
        .circle { width: 100%; height: 30px; filter: blur(2rem); animation: pulse_3011 4s infinite; z-index: -1; }
        .circle:nth-of-type(1) { background: rgba(254, 83, 186, 0.636); }
        .circle:nth-of-type(2) { background: rgba(142, 81, 234, 0.704); }
        .btn:hover #container-stars { z-index: 1; background-color: #212121; }
        .btn:hover { transform: translateY(4em) scale(1.1); }
        .btn:active { border: double 4px #fe53bb; background-origin: border-box; background-clip: content-box, border-box; animation: none; }
        .btn:active .circle { background: #fe53bb; }
        #stars { position: relative; background: transparent; width: 200rem; height: 200rem; }
        #stars::after { content: ""; position: absolute; top: -10rem; left: -100rem; width: 100%; height: 100%; animation: animStarRotate 90s linear infinite; }
        #stars::after { background-image: radial-gradient(#ffffff 1px, transparent 1%); background-size: 50px 50px; }
        #stars::before { content: ""; position: absolute; top: 0; left: -50%; width: 170%; height: 500%; animation: animStar 60s linear infinite; }
        #stars::before { background-image: radial-gradient(#ffffff 1px, transparent 1%); background-size: 50px 50px; opacity: 0.5; }
        @keyframes animStar { from { transform: translateY(0); } to { transform: translateY(-135rem); } }
        @keyframes animStarRotate { from { transform: rotate(360deg); } to { transform: rotate(0); } } @keyframes gradient_301 { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes pulse_3011 { 0% { transform: scale(0.75); box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.7); } 70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(0, 0, 0, 0); } 100% { transform: scale(0.75); box-shadow: 0 0 0 0 rgba(0, 0, 0, 0); } }
        .levelButton { display: none; transform: translateY(3em); align-items: center; background-image: linear-gradient(144deg, #af40ff, #5b42f3 50%, #00ddeb); border: 0; border-radius: 8px; box-shadow: rgba(151, 65, 252, 0.2) 0 15px 30px -5px; box-sizing: border-box; color: #ffffff; font-size: 1.8em; justify-content: center; line-height: 1em; max-width: 100%; min-width: 140px; padding: 3px; text-decoration: none; user-select: none; -webkit-user-select: none; touch-action: manipulation; white-space: nowrap; cursor: pointer; transition: all 0.3s; }
        .levelButton:active, .levelButton:hover { outline: 0; }
        .levelButton span { display: flex; align-items: center; justify-content: center; padding: 16px 24px; height: 100%; width: 100%; background-color: rgb(5, 6, 45); border-radius: 6px; transition: 300ms; }
        .levelButton:hover span { background: none; }
        .levelButton:active { transform: translateY(3em) scale(0.9); }
        .campaignRow { display: flex; flex-direction: row; gap: 2em; }
        #startButton { margin-top: 8em; }
        .simpleButton { margin-top: 1.5em; padding: 0.4em 1em; background-color: transparent; color: #27c39f; border: 2px solid #27c39f; border-radius: 8px; font-size: 0.9em; cursor: pointer; transition: 0.5s ease; }
        .timer { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 2.4em; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .bestTime { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); font-size: 1.2em; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .IGT { position: absolute; top: 55px; left: 50%; transform: translateX(-50%); font-size: 1.2em; color: white; background: rgba(0, 0, 0, 0); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .checkpoint { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); font-size: 1.2em; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 10em; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: "Bungee Spice", sans-serif; display: block; }
        #mapInfo { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 0px; pointer-events: none; text-align: right; z-index: 9999; }
        .times { display: none; justify-content: flex-end; font-size: 1.4em; color: white; background: rgba(0, 0, 0, 0); padding: 5px 10px; border-radius: 5px; font-family: Arial, sans-serif; }
        #debugInfoContainer { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 4px; pointer-events: none; z-index: 9999; }
        .debugInfo { font-size: 1.4em; color: white; background: rgba(0, 0, 0, 0); padding: 5px 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        #versionDisplay { position: fixed; bottom: 2px; left: 0px; font-size: 1em; color: white; padding: 5px 10px; border-radius: 5px; font-family: Arial, sans-serif; display: block; }
        #controlsMenu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(20, 20, 20, 0.95); color: white; padding: 2em; border-radius: 10px; font-family: Arial, sans-serif; font-size: 25px; text-align: center; max-width: 90%; width: 600px; z-index: 100; flex-direction: column; justify-content: space-between; }
        #updatesMenu { display: none; position: absolute; top: 0px; left: 50%; transform: translateX(-50%); color: white; padding: 2em; border-radius: 10px; font-family: Arial, sans-serif; font-size: 24px; text-align: center; max-width: 90%; width: 600px; z-index: 100; flex-direction: column; justify-content: space-between; }
        .embedButton { display: block; position: relative; font-size: 1.2em; color: white; background: rgba(0, 0, 0, 0.5); height: 1.5em; width: 7em; border-radius: 5px; outline: 2px solid white; font-family: Arial, sans-serif; cursor: pointer; }
        .embedButtonRow { display: none; flex-direction: row; gap: 1em; margin-top: -1em; justify-content: right; }
    </style>
</head>
<body>
    <div id="ui-scale-wrapper">
        <div class="title">BHOP</div>
        <div class="timer" id="timer">Time: 0.00s</div>
        <div class="bestTime">Best Time: --.--s</div>
        <div class="IGT">In Game Time: 0.00s</div>
        <div class="checkpoint">Checkpoint: -/-</div>
        <div id="debugInfoContainer">
            <div id="fpsCounter" class="debugInfo">FPS: --</div>
            <div id="positionReporter" class="debugInfo">Position: -, -, -</div>
            <div id="directionReporter" class="debugInfo">Direction: -, -</div>
            <div id="practiceModeReporter" class="debugInfo" style="color: yellow;">PRACTICE MODE</div>
            <div id="manualCheckpointReporter" class="debugInfo">Checkpoints Placed: -</div>
            <div id="testModeReporter" class="debugInfo" style="color: yellow;">TEST MODE</div>
            <div id="worldEligableReporter" class="debugInfo" style="color: red;">TIME NOT ELIGIBLE FOR WORLD RECORD</div>
            <div id="freecamReporter" class="debugInfo">Freecam</div>
            <div id="noclipReporter" class="debugInfo">Noclip</div>
            <div id="playerHitboxReporter" class="debugInfo">Player hitbox</div>
        </div>
        <div id="versionDisplay">v1.4.3.0-alpha</div>
        <div id="mapInfo">
            <div id="mapName" class="times">Map: - by -</div>
            <div id="worldRecord" class="times">World Record: --.-- by -</div>
            <div id="worldRecordButtons" class="embedButtonRow">
                <button id="worldRecordReplay" class="embedButton">Show replay</button>
                <button id="worldRecordGhost" class="embedButton">Show ghost</button>
            </div>
            <div id="authorTime" class="times">Author Record: --.--</div>
            <div id="worldRecordButtons" class="embedButtonRow">
                <button id="worldRecordReplay" class="embedButton">Show replay</button>
                <button id="worldRecordGhost" class="embedButton">Show ghost</button>
            </div>
            <div id="goldTime" class="times">Gold: --.--</div>
            <div id="silverTime" class="times">Silver: --.--</div>
            <div id="bronzeTime" class="times">Bronze: --.--</div>
        </div>
        <button id="startButton" onclick="playClicked('startButton')">P L A Y<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
        <button id="createButton" onclick="window.location.href=window.location.origin + '/editor'">C R E A T E<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
        <button id="controlsButton" onclick="openMenu('controlsMenu')">C O N T R O L S<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
        <div id="controlsMenu">
            <h2>Controls</h2>
            <ul style="list-style: none; padding: 0; text-align: left; margin-top: 1em;">
                <li><b>a/d</b>: Strafe left and right</li>
                <li><b>q/e</b>: look down and up</li>
                <li><b>Space</b>: Jump</li>
                <li><b>r</b>: Restart</li>
                <li><b>m</b>: Restart map (including checkpoints)</li>
                <li><b>f</b>: Toggle freecam mode</li>
                <li><b>w/s</b>: Move forward and backward (freecam)</li>
                <li><b>a/d</b>: Look left and right (freecam)</li>
                <li><b>q/e</b>: look down and up (freecam)</li>
                <li><b>arrow keys</b>: Move left, right, up, and down (freecam)</li>
                <li><b>Space / Shift</b>: Move up and down based on world not pitch and yaw (freecam)</li>
                <li><b>Escape</b></li>
                <li><b>\</b>: Toggle player hitbox (dev tool)</li>
                <li><b>t (pressed 3 times)</b>: Toggle test mode (dev tool)</li>\
                <li><b>0</b>: Replay menu</li>
                <li><b>p</b>: Toggle practice mode</li>
                <li><b>f</b>: Noclipd mode replaces freecam in practice (doesn't reset your position after disabling)</li>
                <li><b>c</b>: Place a checkpoint to spawn to (practice mode)</li>
            </ul><button class="simpleButton" onclick="closeMenu('controlsMenu')">Back</button>
        </div>
        <button id="tutorialButton" onclick="playClicked('tutorialButton')">T U T O R I A L<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
        <button id="updatesButton" onclick="openMenu('updatesMenu')">U P D A T E S<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
        <div id="updatesMenu">
            <h2>What's New? Change log</h2>
            <h3 style="margin-top: 1em;">Minor update 1.4.2.0: 5/17/2025</h3>
            <ul style="text-align: left; margin-top: 1em;">
                <li><b>You should still join the discord server: <a href="https://discord.gg/TcTvmwxgJb" target="_blank">https://discord.gg/TcTvmwxgJb</a></b></li>
                <li><b>Started making pause menu (unfinished)</b></li>
                <li><b>Started developing gameplay replay system (also unfinished)</b></li>
                <li><b>Added a new campaign (player pack 1) with a couple of levels</b>
                    <ul style="margin-left: 1.5em; list-style-type: disc;">
                        <li>Challenge 01 (hopefully 02 and 03 comming soon)</li>
                        <li>Tower 01 and Tower 02 (Tower 03?)</li>
                    </ul></li>
                <li><b>Added practice mode:</b>
                    <ul style="margin-left: 1.5em; list-style-type: disc;">
                        <li>Freecam replaced with noclip in practice that doesn't teleport you back when exiting noclip</li>
                        <li>Can set checkpoints manually by pressing c</li>
                        <li>I did add practice mode reporter and stuff in the top left</li>
                    </ul>
                </li>
            </ul>
            <h3 style="margin-top: 1em;">Bug fix: 1.4.1.2: 5/20/2025</h3>
            <ul style="text-align: left; margin-top: 1em;">
                <li><b>Fixed controls menu (idk why it was broken)</b></li>
                <li><b>World Record Names now can only use letters, numbers, and underscores</b></li>
            </ul>
            <h3 style="margin-top: 1em;">Bug fix: 1.4.1.1: 5/17/2025</h3>
            <ul style="text-align: left; margin-top: 1em;">
                <li><b>Fixed killbox floor collisions (much more lenient), now won't kill you if you overlap on normal and kill boxes (as intended)</b></li>
            </ul>
            <button class="simpleButton" onclick="closeMenu('updatesMenu')">
                Back
            </button>
        </div>
        <button id="creditsButton" onclick="openMenu('creditsMenu')">
            C R E D I T S
            <div id="clip">
                <div id="leftTop" class="corner"></div>
                <div id="rightBottom" class="corner"></div>
                <div id="rightTop" class="corner"></div>
                <div id="leftBottom" class="corner"></div>
            </div>
            <span id="rightArrow" class="arrow"></span>
            <span id="leftArrow" class="arrow"></span>
        </button>
        <div id="creditsMenu" style="
            display: none;
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            padding: 2em;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            font-size: 25px;
            text-align: center;
            max-width: 90%;
            width: 600px;
            z-index: 100;
            flex-direction: column;
            justify-content: space-between;
        ">
            <h2>Credits</h2>
            <ul style="list-style: none;">
            <li>⠀</li>
            </ul>
            <h3>Joshua Harding</h3>
            <ul style="list-style: none; padding: 0; text-align: left;">
                <li>⠀</li>
            </ul>
            <ul style="text-align: left;">
                <li>I made the levels</li>
                <li>Made the movement</li>
                <li>Made all the buttons and ui</li>
                <li>Coded freecam</li>
                <li>Added all different types of boxes</li>
                <li>Fixed and coded editor</li>
                <li>Finished making world records work</li>
                <li>If you couldn't tell, I run the website</li>
                <li>Tell me if theres a bug, i'll fix it</li>
            </ul> 
            <ul style="list-style: none; padding: 0; text-align: left;">
                <li>⠀</li>
            </ul> 
            <h3>Ben Messer</h3>
            <ul style="list-style: none; padding: 0; text-align: left;">
                <li>⠀</li>
            </ul>
            <ul style="text-align: left;">
                <li>He inspired the project</li>
                <li>Made the .json level idea</li>
                <li>Came up with editor and started coding it</li>
                <li>I took the freecam movement from one of his projects and altered it</li>
                <li>Advertising</li>
                <li>He started making world records work and made the post function in the apps script, without him I would be lost</li>
            </ul>
            <ul style="list-style: none; padding: 0; text-align: left;">
                <li>⠀</li>
            </ul> 
            <h3>Liam Reinert</h3>
            <ul style="list-style: none; padding: 0; text-align: left;">
                <li>⠀</li>
            </ul>
            <ul style="text-align: left;">
                <li>Made tutorial levels</li>
                <li>Supports the game's development process</li>
                <li>Playtested and reported bugs</li>
            </ul>
            <button class="simpleButton" onclick="closeMenu('creditsMenu')">
                Back
            </button>
        </div>
        <button id = "campaign1" type ="button" class="btn" onclick="showCampaign('1')">
            <strong>CAMPAIGN 1</strong>
            <div id="container-stars">
                <div id="stars"></div>
            </div>
            <div id="glow">
                <div class="circle"></div>
                <div class="circle"></div>
            </div>
        </button>
        <button id = "campaign2" type ="button" class="btn">
            <strong>COMMING SOON</strong>
            <div id="container-stars">
                <div id="stars"></div>
            </div>
            <div id="glow">
                <div class="circle"></div>
                <div class="circle"></div>
            </div>
        </button>
        <button id = "campaign3" type ="button" class="btn" onclick="showCampaign('3')">
            <strong>PLAYER PACK 1</strong>
            <div id="container-stars">
                <div id="stars"></div>
            </div>
            <div id="glow">
                <div class="circle"></div>
                <div class="circle"></div>
            </div>
        </button>
        <button id="loadLevel" type="button" class="btn" onclick="startGame('loadLevel')">
            <strong>LOAD CUSTOM LEVEL</strong>
            <div id="container-stars" style="margin-top: -2.8em;">
                <div id="stars"></div>
            </div>
            <div id="glow">
                <div class="circle"></div>
                <div class="circle"></div>
            </div>
        </button>
        <div id="campaign0Levels">
            <div class="campaignRow">
                <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 1, startGame()"><span>Open World</span></button>
                <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 2, startGame()"><span>Tunnel</span></button>
                <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 3, startGame()"><span>First Danger</span></button>
            </div>
            <div class="campaignRow">
                <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 4, startGame()"><span>Collect the Yellow!</span></button>
                <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 5, startGame()"><span>Teleporter Intro</span></button>
                <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 6, startGame()"><span>Compilation</span></button>
            </div>
        </div>
        <div id="campaign1Levels">
            <div class="campaignRow">
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 1, startGame()"><span>Labyrinth 01</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 2, startGame()"><span>Labyrinth 02</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 3, startGame()"><span>Labyrinth 03</span></button>
            </div>
            <div class="campaignRow">
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 4, startGame()"><span>KillLevel 01</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 5, startGame()"><span>KillLevel 02</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 6, startGame()"><span>KillLevel 03</span></button>
            </div>
            <div class="campaignRow">
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 7, startGame()"><span>CheckpointLevel 01</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 8, startGame()"><span>CheckpointLevel 02</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 9, startGame()"><span>CheckpointLevel 03</span></button>
            </div>
            <div class="campaignRow">
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 91, startGame()"><span>TeleportLevel 01</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 92, startGame()"><span>TeleportLevel 02</span></button>
                <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 93, startGame()"><span>TeleportLevel 03</span></button>
            </div>
        </div>
        <div id="campaign3Levels">
            <div class="campaignRow">
                <button id="campaign3LevelButton" type="button" class="levelButton" onclick="campaignNumber = 3, campaignLevel = 1, startGame()"><span>Challenge 01</span></button>
                <button id="campaign3LevelButton" type="button" class="levelButton" onclick="// campaignNumber = 3, campaignLevel = 2, startGame()"><span>Not Available</span></button>
                <button id="campaign3LevelButton" type="button" class="levelButton" onclick="// campaignNumber = 3, campaignLevel = 3, startGame()"><span>Not Available</span></button>
            </div>
            <div class="campaignRow">
                <button id="campaign3LevelButton" type="button" class="levelButton" onclick="campaignNumber = 3, campaignLevel = 4, startGame()"><span>Tower 01</span></button>
                <button id="campaign3LevelButton" type="button" class="levelButton" onclick="campaignNumber = 3, campaignLevel = 5, startGame()"><span>Tower 02</span></button>
                <button id="campaign3LevelButton" type="button" class="levelButton" onclick="// campaignNumber = 3, campaignLevel = 6, startGame()"><span>Not Availible</span></button>
            </div>
        </div>
        <form id="worldRecordMenu" style="
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(20, 20, 20, 0.95);
        color: white;
        padding: 2em;
        border-radius: 10px;
        font-family: Arial, sans-serif;
        font-size: 2.5em;
        text-align: center;
        max-width: 90%;
        width: 640px;
        z-index: 100;
        flex-direction: column;
        justify-content: space-between;
        "
        action="https://script.google.com/macros/s/AKfycbzQoL-7mvmi8fZS0umv3IfL7bdAZpTQLPUZgKAQ85veqnZkU8dh85eS3klzU78gtvoXmg/exec" method="post" target="hidden_iframe" onsubmit="submitted=true;">
            <h2 style="margin-top: -0.8em;">World Record!</h2>
            <h4 style="margin-top: 0.2em;">Enter your name</h4>
            <h4 style="margin-top: -0em;">(to be recognized)</h4>
            <label for="name" style="margin-top: 0.5em;">Name:</label>
            <input type="text" id="name" placeholder="type here" maxlength="20" pattern="[A-Za-z0-9_]*" style="
                margin-top: 0.5em;
                color: white;
                padding: 0.4em 1em;
                background-color: transparent;
                border: 2px solid #27c39f;
                border-radius: 8px;
                font-size: 40px;
                cursor: pointer;
                transition: 0.5s ease;
            "
            name="name" required><br><br>
            <input type="hidden" id="time" name="time" value="">
            <input type="hidden" id="level" name="level" value="">
            <input type="hidden" id="key" name="key" value="c2VjdXJla2V5X2hleV9mcmllbmQa">
            <input type="hidden" id="replayData" name="replayData" value="">
            <input type="hidden" id="publicReplayData" name="publicReplayData" value="">
            <input type="hidden" id="versionNumber" name="versionNumber" value="">
            <div id="charCounter" style="font-size: 40px; color: gray; margin-bottom: 1em; margin-top: -80px;">0 / 20</div>
            <input type="submit" class="simpleButton" style="margin-top: 0em;" value="Submit">
            <button class="simpleButton" style="height: 2.2em; width: 13.33333em; margin-top: 0.1em;" onclick="worldRecordMenu.style.display = 'none', playing = true">No Thanks</button>
        </form>
        <form id="replayMenu" autocomplete="off" style="
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 20, 0.95);
            color: white;
            padding: 2em;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            font-size: 2.5em;
            text-align: center;
            max-width: 90%;
            width: 640px;
            z-index: 100;
            flex-direction: column;
            justify-content: space-between;
        ">
            <h2 style="margin-top: -0.8em;">Watch Replays</h2>
            <label for="replayCode" style="margin-top: 0.5em;">Replay Code:</label>
            <input type="text" id="replayCode" placeholder="paste replay code here" style="
                margin-top: 0.5em;
                color: white;
                padding: 0.4em 1em;
                background-color: transparent;
                border: 2px solid #27c39f;
                border-radius: 8px;
                font-size: 40px;
                cursor: pointer;
                transition: 0.5s ease;
            "
            name="replayCode" required><br><br>
            <input type="submit" class="simpleButton" style="margin-top: 0em;" value="Submit">
            <button type="button" class="simpleButton" style="height: 2.2em; width: 13.33333em; margin-top: 0.1em;" onclick="replayMenu.style.display = 'none'; playing = true;">Close</button>
        </form>
        <div id="pauseMenu" style="
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(20, 20, 20, 0.95);
        color: white;
        padding: 2em;
        border-radius: 10px;
        font-family: Arial, sans-serif;
        font-size: 25px;
        text-align: center;
        max-width: 90%;
        width: 600px;
        z-index: 100;
        flex-direction: column;
        justify-content: space-between;
        ">
            <h1 style="margin-top: -0.5em;">Paused</h1>
            <button class="simpleButton" style="margin-top: 1em; width: 500px;" onclick="playing = true, document.getElementById('pauseMenu').style.display = 'none'">
                <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Resume</span>
            </button>
            <button class="simpleButton" style="margin-top: -0.5em; width: 500px;" onclick="">
                <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Coming Soon</span>
            </button>
            <button class="simpleButton" style="margin-top: -0.5em; width: 500px;" onclick="">
                <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Coming Soon</span>
            </button>
            <button class="simpleButton" style="margin-top: -0.5em; width: 500px;" onclick="location.reload();">
                <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Exit</span>
            </button>
        </div>
    </div>
    <iframe name="hidden_iframe" id="hidden_iframe" style="display:none;"></iframe>
    <input type="file" id="fileInput" style="display: none;" accept=".json">
    <script>
        // THREE.js setup
        let scene, camera, renderer;
        let cameraRig;
        let direction = new THREE.Vector3();
        let velocity = new THREE.Vector3(0, 0, 0);
        let collidableObjects = [];
        let objectsInScene = [];
        let playerBoxHelper;
        let nextBoxHelper;
        let sweptBoxHelper;
        let playerViewLine;
        let checkpointHelpers = [];
        let targetAspectRatio = 16 / 9;
        // UI elements
        let fpsCounter = document.getElementById("fpsCounter");
        let positionReporter = document.getElementById("positionReporter");
        let directionReporter = document.getElementById("directionReporter");
        let practiceModeReporter = document.getElementById("practiceModeReporter");
        let manualCheckpointReporter = document.getElementById("manualCheckpointReporter");
        let testModeReporter = document.getElementById("testModeReporter");
        let worldEligableReporter = document.getElementById("worldEligableReporter");
        let freecamReporter = document.getElementById("freecamReporter");
        let noclipReporter = document.getElementById("noclipReporter");
        let playerHitboxReporter = document.getElementById("playerHitboxReporter");
        let mapInfo = document.getElementById("mapInfo");
        let worldRecordMenu = document.getElementById("worldRecordMenu");
        let nameInput = document.getElementById("name");
        let charCounter = document.getElementById("charCounter");
        let pauseMenu = document.getElementById("pauseMenu");
        // THREE.js movement
        let keys = { w: false, a: false, s: false, d: false, space: false, e: false, q: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false };
        let speed = 0.5;
        let freecamSpeed = 0.05;
        let gravity = -0.01;
        let jumpPower = 0.25;
        let isJumping = false;
        let isGrounded = false;
        let strafeDirection = 0;
        let strafeSpeed = 0.08; // (radians per frame)
        // Storing camera and pos data
        let startPosition = new THREE.Vector3(0, 1, 3.9);
        let radians = 0; // radians refers to the yaw of the cameraRig stored in checkpoint and teleport box data in level files
        let storedVelocity = new THREE.Vector3(0, 0, 0);
        // These are used for freecam - returning player to original state before freecam was activated after it was deactivated
        let storedPosition = new THREE.Vector3(0, 1, 3.9);
        let storedYaw = 0;
        let storedPitch = 0;
        // These are the same but used for manual checkpoints in practice mode
        let storedYaw2 = 0;
        let storedPitch2 = 0;
        let storedVelocity2 = new THREE.Vector3(0, 0, 0);
        // fps stuff
        let fps;
        let lastTeleportTime = 0;
        let lastFrameTime = performance.now();
        let fpsUpdateInterval = 500; // Update every 500ms
        let fpsTimeAccumulator = 0;
        let frameCount = 0;
        let IGT = 0;
        let finishedIGT = 0;
        let deltaTime = 0;
        // special boxes stuff
        let checkpoints = null; // Number of checkpoints
        let checkpoint = null; // Current checkpoint (out of number of checkpoints)
        let lastTeleportedBox = null;
        let destination = null;
        // timer stuff
        let timer = false;
        let startTime = null;
        let timerInterval = null;
        let timerOffset = 0;
        let elapsedTime = 0;
        // level stuff
        let versionNumber = document.getElementById("versionDisplay").innerText;
        let campaignNumber = null;
        let campaignLevel = null;
        let bestTime = Infinity;
        let mapName = null;
        let mapAuthor = null;
        let worldRecordTime = -Infinity;
        let authorTime = null;
        let goldTime = null;
        let silverTime = null;
        let bronzeTime = null;
        let lastRecordFetchTime = 0;
        let recordFetchCooldown = 3000; // ms
        // game states
        let playing = false;
        let freecam = false;
        let noclip = false;
        let showHitbox = false;
        let testMode = false;
        let testStep = false;
        let tPresses = 0;
        let lastTPressTime = 0;
        let timerStopped = false;
        let worldEligable = true;
        let practiceMode = false;
        // replay and recording stuff
        let replayRecording = []; // stores input per frame
        let publicReplayRecording = []; // position + rotation per frame
        let isRecording = false;  // flag for when to record
        let isReplaying = false;
        let queuedKeyPresses = { r: false };
        let replayFrames = [];
        let replayIndex = 0;
        let replayTimer = 0;
        let isPublicReplaying = false;
        let publicReplayFrames = [];
        let publicReplayIndex = 0;
        function hideMenuButtons() {
            document.getElementById("startButton").style.display = "none";
            document.getElementById("createButton").style.display = "none";
            document.getElementById("controlsButton").style.display = "none";
            document.getElementById("tutorialButton").style.display = "none";
            document.getElementById("updatesButton").style.display = "none";
            document.getElementById("creditsButton").style.display = "none";
        }
        function showMenuButtons() {
            document.getElementById("startButton").style.display = "block";
            document.getElementById("createButton").style.display = "block";
            document.getElementById("controlsButton").style.display = "block";
            document.getElementById("tutorialButton").style.display = "block";
            document.getElementById("updatesButton").style.display = "block";
            document.getElementById("creditsButton").style.display = "block";
        }
        function openMenu(menuName) {
            hideMenuButtons();
            document.querySelector(".title").style.display = "none";
            const menu = document.getElementById(menuName);
            menu.style.display = "block";
            requestAnimationFrame(() => menu.classList.add("show"));
        }
        function closeMenu(menuName) {
            const menu = document.getElementById(menuName);
            menu.classList.remove("show");
            setTimeout(() => {
                menu.style.display = "none";
                showMenuButtons();
                document.querySelector(".title").style.display = "block";
            }, 300); // matches the CSS transition duration
        }
        function playClicked(button) {
            hideMenuButtons();
            if (button === "startButton") {
                showPlayOptions();
            } else if (button === "tutorialButton") {
                showCampaign(0);
            }
        }
        function showPlayOptions() {
            document.getElementById("campaign1").style.display = "block";
            document.getElementById("campaign2").style.display = "block";
            document.getElementById("campaign3").style.display = "block";
            document.getElementById("loadLevel").style.display = "block";
        }
        function hidePlayOptions() {
            document.getElementById("campaign1").style.display = "none";
            document.getElementById("campaign2").style.display = "none";
            document.getElementById("campaign3").style.display = "none";
            document.getElementById("loadLevel").style.display = "none";
        }
        function showCampaign(campaignNumber) {
            hidePlayOptions();
            const levelsContainer = document.getElementById("campaign" + campaignNumber + "Levels");
            levelsContainer.style.display = "block";
            const levelButtons = levelsContainer.querySelectorAll(".levelButton");
            levelButtons.forEach(btn => {
                btn.style.display = "flex";
            });
        }
        function hideCampaign(campaignNumber) {
            hidePlayOptions();
            const levelsContainer = document.getElementById("campaign" + campaignNumber + "Levels");
            levelsContainer.style.display = "none";
            const levelButtons = levelsContainer.querySelectorAll(".levelButton");
            levelButtons.forEach(btn => {
                btn.style.display = "none";
            });
        }
        function startGame(initCommand) {
            document.querySelector(".title").style.display = "none";
            hideMenuButtons();
            hidePlayOptions();
            document.body.style.backgroundColor = "transparent"; // Change background to transparent
            fpsCounter.style.display = "block";
            positionReporter.style.display = "block";
            directionReporter.style.display = "block";
            if (initCommand === "loadLevel") {
                init("loadLevel")
            } else {
                hideCampaign(campaignNumber)
                mapInfo.style.display = "block";
                const times = mapInfo.querySelectorAll(".times");
                const embedButtonRows = mapInfo.querySelectorAll(".embedButtonRow");
                times.forEach(div => {
                    div.style.display = "flex";
                });
                embedButtonRows.forEach(button => {
                    button.style.display = "flex";
                });
                init();
            }
        }
        function handleFileImport(event) {
            if (!playing) {
                startGame();
            }
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const levelData = JSON.parse(e.target.result);
                clearScene();
                loadLevel(levelData);
            };
            reader.readAsText(file);
        }
        function init(initCommand) {
            if (initCommand === "loadLevel") {
                document.getElementById("fileInput").click();
            }
            if (campaignNumber !== null & campaignLevel !== null) {
                loadLevelFromFile("campaign"+campaignNumber+"."+campaignLevel)
            }
            playing = true;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // camera stays at origin within the rig
            cameraRig = new THREE.Object3D();
            cameraRig.position.copy(startPosition);
            cameraRig.add(camera);
            scene.add(cameraRig);  
            const playerSize = new THREE.Vector3(1, 2, 1);
            let initialBox = new THREE.Box3().setFromCenterAndSize(cameraRig.position.clone(), playerSize);
            playerBoxHelper = new THREE.Box3Helper(initialBox, 0xffa500);
            playerBoxHelper.visible = false;
            scene.add(playerBoxHelper);   
            // Box for next frame position (light blue)
            nextBoxHelper = new THREE.Box3Helper(new THREE.Box3(), 0x00ffff);
            nextBoxHelper.visible = false;
            scene.add(nextBoxHelper);
            // Swept box (orange)
            sweptBoxHelper = new THREE.Box3Helper(new THREE.Box3(), 0xffff00);
            sweptBoxHelper.visible = false;
            scene.add(sweptBoxHelper);
            // Create a red line from eye height to forward direction
            const cylGeom = new THREE.CylinderGeometry(0.025, 0.025, 1, 8, 1, true);
            const cylMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            playerViewLine = new THREE.Mesh(cylGeom, cylMat);
            playerViewLine.visible = false;
            scene.add(playerViewLine);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener("resize", () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspect = width / height;
                let viewportWidth, viewportHeight, offsetX, offsetY;
                if (aspect > targetAspectRatio) {
                    // Window is too wide → pillarbox
                    viewportHeight = height;
                    viewportWidth = height * targetAspectRatio;
                    offsetX = (width - viewportWidth) / 2;
                    offsetY = 0;
                } else {
                    // Window is too tall → letterbox
                    viewportWidth = width;
                    viewportHeight = width / targetAspectRatio;
                    offsetX = 0;
                    offsetY = (height - viewportHeight) / 2;
                }
                // Resize renderer to fill entire screen (so black bars show)
                renderer.setSize(width, height);
                renderer.setViewport(offsetX, offsetY, viewportWidth, viewportHeight);
                renderer.setScissor(offsetX, offsetY, viewportWidth, viewportHeight);
                renderer.setScissorTest(true);
                camera.aspect = targetAspectRatio; // Always use fixed 16:9
                camera.updateProjectionMatrix();
            });
            window.dispatchEvent(new Event("resize"));
            let hideCursorTimeout;
            // Hide cursor immediately after keypress
            document.addEventListener("keydown", () => {
                document.body.style.cursor = "none";
            });
            document.addEventListener("mousemove", () => {
                document.body.style.cursor = "default";
            });
            window.addEventListener("keydown", (event) => {
                if (event.key === "Escape") {
                    if (pauseMenu.style.display === "none") {
                        pauseMenu.style.display = "block";
                        if (!freecam) storedVelocity = velocity.clone();
                        velocity.set(0, 0, 0);
                        playing = false;
                    } else {
                        pauseMenu.style.display = "none";
                        velocity.copy(storedVelocity);
                        if (worldRecordMenu.style.display === "none") playing = true;
                    }
                }
                if (playing) {
                    if (event.key === "\\") {
                        showHitbox = !showHitbox;
                        playerBoxHelper.visible = showHitbox;
                        playerViewLine.visible = showHitbox;
                        nextBoxHelper.visible = showHitbox;
                        sweptBoxHelper.visible = showHitbox;
                    }
                    if (event.key === "t") {
                        const now = performance.now();
                        if (now - lastTPressTime < 1000) {
                            tPresses++;
                        } else {
                            tPresses = 1;
                        }
                        lastTPressTime = now;
                        if (tPresses >= 3) {
                            testMode = !testMode;
                            testStep = false;
                            tPresses = 0;
                            worldEligable = false;
                        }
                    }
                    if (testMode && event.key !== " " && event.key !== "t") {
                        testStep = true;
                    }
                    if (event.key in keys && !isReplaying) keys[event.key] = true;
                    if (event.key === " ") keys.space = true;
                    if (event.key === "0") {
                        if (replayMenu.style.display === "none") {
                            replayMenu.style.display = "flex";
                            playing = false;
                        } else {
                            replayMenu.style.display = "none";
                            playing = true;
                        }
                    }
                    if (event.key === "r") {
                        queuedKeyPresses.r = true;
                        resetPlayer();
                        if (checkpoint === 0 && checkpointHelpers.length === 0 && !freecam) resetTimer();
                    }
                    if (event.key === "m") {
                        resetMap();
                    }
                    if (event.key === "p") {
                        if (!practiceMode) {
                            practiceMode = true;
                            worldEligable = false;
                            noclip = freecam;
                            freecam = false;
                        } else {
                            practiceMode = false;
                            freecam = false;
                            noclip = false;
                            startPosition = new THREE.Vector3(0, 1, 3.9);
                            radians = 0;
                            checkpointHelpers.forEach(helper => {
                                scene.remove(helper);
                                if (helper.geometry) helper.geometry.dispose();
                                if (helper.material) helper.material.dispose();
                            });
                            checkpointHelpers.length = 0;
                            resetPlayer();
                            resetTimer();
                            checkpoint = 0;
                            collidableObjects.forEach(obj => {
                                if (obj.mesh.isCheckpointBox) {
                                    obj.mesh.visible = true;
                                }
                            });
                        }
                    }
                    if (!practiceMode) {
                        if (event.key === "f") {
                            if (!freecam) {
                                storedPosition = startPosition;
                                startPosition = new THREE.Vector3(cameraRig.position.x, cameraRig.position.y, cameraRig.position.z);
                                storedYaw = cameraRig.rotation.y;
                                storedPitch = camera.rotation.x;
                                storedVelocity = velocity.clone();
                                velocity.set(0, 0, 0);
                                freecam = true;
                            } else {
                                isGrounded = false;
                                cameraRig.position.copy(startPosition);
                                velocity.set(0, 0, 0);
                                camera.rotation.set(0, 0, 0);
                                cameraRig.rotation.y = storedYaw;
                                camera.rotation.x = storedPitch;
                                startPosition = storedPosition;
                                velocity.copy(storedVelocity);
                                freecam = false;
                            }
                        }
                    } else {
                        if (event.key === "f") {
                            if (!noclip) {
                                storedPosition = startPosition;
                                startPosition = new THREE.Vector3(cameraRig.position.x, cameraRig.position.y, cameraRig.position.z);
                                storedYaw = cameraRig.rotation.y;
                                storedPitch = camera.rotation.x;
                                storedVelocity = velocity.clone();
                                velocity.set(0, 0, 0);
                                noclip = true;
                            } else {
                                isGrounded = false;
                                noclip = false;
                            }
                        }
                        if (event.key === "c") {
                            startPosition = new THREE.Vector3(cameraRig.position.x, cameraRig.position.y, cameraRig.position.z);
                            storedYaw2 = cameraRig.rotation.y;
                            storedPitch2 = camera.rotation.x;
                            storedVelocity2 = velocity.clone();
                            const checkpointBoxSize = new THREE.Vector3(1, 2, 1);
                            const checkpointBox = new THREE.Box3().setFromCenterAndSize(startPosition.clone(), checkpointBoxSize);
                            const checkpointBoxHelper = new THREE.Box3Helper(checkpointBox, 0xffff00); // Yellow for checkpoint
                            scene.add(checkpointBoxHelper);
                            checkpointHelpers.push(checkpointBoxHelper);
                            const eyeHeight = 0.8;
                            const eyePos = startPosition.clone().add(new THREE.Vector3(0, eyeHeight, 0));
                            const viewDir = new THREE.Vector3();
                            camera.getWorldDirection(viewDir);
                            const length = 3;
                            const endPos = eyePos.clone().add(viewDir.clone().multiplyScalar(length));
                            const mid = eyePos.clone().add(endPos).multiplyScalar(0.5);
                            const geometry = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
                            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                            const checkpointViewLine = new THREE.Mesh(geometry, material);
                            checkpointViewLine.position.copy(mid);
                            checkpointViewLine.lookAt(endPos);
                            checkpointViewLine.rotateX(Math.PI / 2);
                            scene.add(checkpointViewLine);
                            checkpointHelpers.push(checkpointViewLine);
                        }
                    }
                }
            });
            window.addEventListener("keyup", (event) => {
                if (event.key in keys && !isReplaying) keys[event.key] = false;
                if (event.key === " ") keys.space = false;
            });
            window.addEventListener("blur", () => {
                for (let key in keys) keys[key] = false;
            });
            document.getElementById("fileInput").addEventListener("change", handleFileImport);
            animate(performance.now());
        }
        function clearScene() {
            objectsInScene.forEach(obj => scene.remove(obj));
            objectsInScene = [];
            collidableObjects = [];
        }
        function loadLevelFromFile(filename) {
            const baseUrl = window.location.origin; // Get the base URL (e.g., https://joshuaharding2.codehs.me)
            const absoluteUrl = `${baseUrl}/${filename}.json`; // Construct the full URL
            fetch(absoluteUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load level file: ${absoluteUrl} (Status: ${response.status})`);
                }
                return response.text(); // Get text first
            })
            .then(text => {
                try {
                    const levelData = JSON.parse(text); // Parse JSON data
                    clearScene();
                    loadLevel(levelData); // Load the level
                } catch (e) {
                    throw e; // Rethrow error for logging
                }
            })
            .catch(error => {
            });
        }
        function loadLevel(levelData) {
            timer = false;
            bestTime = Infinity;
            document.querySelector(".bestTime").innerText = `Best Time: --.--s`;
            checkpoints = 0;
            checkpoint = 0;
            // Handle optional editorData and medal times
            if (levelData[0]?.editorData && campaignNumber != null && campaignLevel != null) {
                const meta = levelData[0];
                // Safe extraction of map info
                mapName = meta.mapName ?? null;
                mapAuthor = meta.mapAuthor ?? null;
                authorTime = meta.authorTime ?? null;
                goldTime = meta.goldTime ?? null;
                silverTime = meta.silverTime ?? null;
                bronzeTime = meta.bronzeTime ?? null;
                if (mapName !== null && mapAuthor !== null) {
                    document.getElementById("mapName").innerText = `Map: ${mapName} by ${mapAuthor}`;
                }
                if (authorTime !== null) {
                    document.getElementById("authorTime").innerText = `Author Record: ${authorTime.toFixed(2)}`;
                }
                if (goldTime !== null) {
                    document.getElementById("goldTime").innerText = `Gold: ${goldTime.toFixed(2)}`;
                }
                if (silverTime !== null) {
                    document.getElementById("silverTime").innerText = `Silver: ${silverTime.toFixed(2)}`;
                }
                if (bronzeTime !== null) {
                    document.getElementById("bronzeTime").innerText = `Bronze: ${bronzeTime.toFixed(2)}`;
                }
            }
            // Load box data (starting from index 1 if editorData was present)
            const startIndex = (levelData[0]?.editorData) ? 1 : 0;
            for (let i = startIndex; i < levelData.length; i++) {
                const box = levelData[i];
                // existing loading logic...
                let width = Math.abs(box.end.x - box.start.x) || 1;
                let height = Math.abs(box.end.y - box.start.y) || 1;
                let depth = Math.abs(box.end.z - box.start.z) || 1;
                let material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                if (box.type === "end") {
                    material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                } else if (box.type === "kill") {
                    material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
                } else if (box.type === "checkpoint") {
                    material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                } else if (box.type === "teleport") {
                    material = new THREE.MeshBasicMaterial({ color: 0xaa00ff, wireframe: true });
                } else if (box.type === "ice") {
                    material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
                }
                let geometry = new THREE.BoxGeometry(width, height, depth);
                let mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (box.start.x + box.end.x) / 2,
                    (box.start.y + box.end.y) / 2,
                    (box.start.z + box.end.z) / 2
                );
                if (box.type === "end") {
                    mesh.isEndBox = true;
                    timer = true;
                }
                if (box.type === "kill") {
                    mesh.isKillBox = true;
                }
                if (box.type === "checkpoint") {
                    mesh.isCheckpointBox = true;
                    checkpoints++;
                    mesh.degrees = box.degrees ?? 0;
                }
                if (box.type === "teleport") {
                    mesh.isTeleportBox = true;
                    mesh.degrees = box.degrees ?? 0;
                    mesh.teleportId = box.teleportId;
                }
                if (box.type === "ice") {
                    mesh.isIceBox = true;
                }
                scene.add(mesh);
                objectsInScene.push(mesh);
                const boundingBox = new THREE.Box3().setFromObject(mesh);
                collidableObjects.push({ mesh: mesh, box: boundingBox });
            }
            freecam = false;
            startPosition = new THREE.Vector3(0, 1, 3.9);
            radians = 0;
            resetPlayer();
            resetTimer();
            checkpoint = 0;
            collidableObjects.forEach(obj => {
                if (obj.mesh.isCheckpointBox) {
                    obj.mesh.visible = true;
                }
            });
        }
        function checkCollisions(prevPosition, nextPosition) {
            const playerSize = new THREE.Vector3(1, 2, 1);
            // Swept box for detecting fast movement collisions
            let sweptMin = prevPosition.clone().min(nextPosition).sub(playerSize.clone().multiplyScalar(0.5));
            let sweptMax = prevPosition.clone().max(nextPosition).add(playerSize.clone().multiplyScalar(0.5));
            let sweptBox = new THREE.Box3(sweptMin, sweptMax);
            // Box at current and next positions
            let currentBox = new THREE.Box3().setFromCenterAndSize(prevPosition, playerSize);
            let nextBox = new THREE.Box3().setFromCenterAndSize(nextPosition, playerSize);
            let collisionDetected = false; // default: no collision
            collidableObjects.forEach(obj => {
                if (!obj.mesh.isEndBox && !obj.mesh.isCheckpointBox && !obj.mesh.isKillBox && !obj.mesh.isTeleportBox && !obj.mesh.isIceBox) {
                    if (sweptBox.intersectsBox(obj.box)) {
                        collisionDetected = true; // normal solid collision
                    }
                } else if (obj.mesh.isKillBox) {
                    // Create a clone of currentBox and shift its bottom edge up very slightly
                    const paddedBox = currentBox.clone();
                    paddedBox.min.y += 0.2; // only affect the bottom
                    if (paddedBox.intersectsBox(obj.box)) {
                        collisionDetected = true;
                        resetPlayer();
                        if (checkpoint === 0) resetTimer();
                    }
                } else if (obj.mesh.isIceBox) {
                    if (sweptBox.intersectsBox(obj.box)) {
                        collisionDetected = "ice"; // ice collision
                    }
                }
            });
            // Check for touching the end box using current position
            collidableObjects.forEach(obj => {
                if (obj.mesh.isEndBox && currentBox.intersectsBox(obj.box)) {
                    if (checkpoint === checkpoints) {
                        timerStopped = true;
                        document.getElementById("timer").style.color = "lime";
                        document.querySelector(".IGT").style.color = "lime";
                        if (!isNaN(IGT) && !isNaN(elapsedTime)) {
                            finishedIGT = Math.min(IGT, elapsedTime);
                        }
                        if (elapsedTime < bestTime) {
                            bestTime = elapsedTime;
                            document.querySelector(".bestTime").innerText = `Best Time: ${bestTime.toFixed(2)}s`;
                            document.querySelector(".bestTime").style.color = "lime";
                            if (bestTime < worldRecordTime && campaignNumber !== null && campaignLevel !== null && worldEligable) worldRecordMenu.style.display = "flex", playing = false;
                            if (bestTime <= authorTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                                document.getElementById("silverTime").style.color = "lime";
                                document.getElementById("goldTime").style.color = "lime";
                                document.getElementById("authorTime").style.color = "lime";
                            } else if (bestTime <= goldTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                                document.getElementById("silverTime").style.color = "lime";
                                document.getElementById("goldTime").style.color = "lime";
                            } else if (bestTime <= silverTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                                document.getElementById("silverTime").style.color = "lime";
                            } else if (bestTime <= bronzeTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                            }
                        }
                    } else {
                        document.querySelector(".checkpoint").style.color = "red";
                    }
                } else {
                    if (checkpoint === checkpoints) {
                        document.querySelector(".checkpoint").style.color = "lime";
                    } else {
                        document.querySelector(".checkpoint").style.color = "white";
                    }
                }
            });
            // Checkpoint boxes using current position
            collidableObjects.forEach(obj => {
                if (obj.mesh.isCheckpointBox && obj.mesh.visible && currentBox.intersectsBox(obj.box)) {
                    checkpoint++;
                    obj.mesh.visible = false;
                    startPosition = obj.mesh.position;
                    if (obj.mesh.degrees !== undefined) radians = obj.mesh.degrees * Math.PI / 180;
                }
            });
            // Teleport boxes using current position
            collidableObjects.forEach(obj => {
                if (obj.mesh.isTeleportBox && currentBox.intersectsBox(obj.box) && !collisionDetected) {
                    collisionDetected = true;
                    if (obj !== lastTeleportedBox) {
                        handleTeleportCollision(obj, currentBox);
                    }
                } else {
                    destination = null;
                }
            });
            return collisionDetected;
        }
        function handleTeleportCollision(enteredBox, currentBox) {
            const now = performance.now();
            const delta = now - lastTeleportTime;
            if (destination === enteredBox) {
                return;
            }
            if (lastTeleportedBox === enteredBox) {
                return;
            }
            lastTeleportTime = now;
            const enteredId = enteredBox.mesh.teleportId;
            const destinations = collidableObjects.filter(obj =>
                obj.mesh.isTeleportBox &&
                obj.mesh.teleportId == enteredId &&
                obj !== enteredBox
            );
            if (destinations.length > 0) {
                destination = destinations[Math.floor(Math.random() * destinations.length)];
                const targetPos = destination.box.getCenter(new THREE.Vector3());
                const targetRotDeg = destination.mesh.degrees ?? 0;
                const targetRotRad = THREE.MathUtils.degToRad(targetRotDeg);
                // Move player to center of teleport destination
                isGrounded = false;
                cameraRig.position.copy(targetPos);
                cameraRig.rotation.y = targetRotRad;
                // Push the player slightly in the "forward" direction
                const forward = new THREE.Vector3(
                    -Math.sin(targetRotRad),
                    0,
                    -Math.cos(targetRotRad)
                );
                forward.normalize();
                cameraRig.position.addScaledVector(forward, 1); // Push by 1 unit forward
                lastTeleportedBox = enteredBox;
                setTimeout(() => {
                    lastTeleportedBox = null;
                }, 300);
            }
        }
        function resetPlayer() {
            isGrounded = false;
            cameraRig.position.copy(startPosition);
            velocity.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            cameraRig.rotation.y = radians;
            if (checkpointHelpers.length > 0) {
                isGrounded = false;
                velocity.set(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                cameraRig.rotation.y = storedYaw2;
                camera.rotation.x = storedPitch2;
                velocity.copy(storedVelocity2);
            }
        }
        function resetMap() {
            freecam = false;
            startPosition = new THREE.Vector3(0, 1, 3.9);
            radians = 0;
            checkpointHelpers.forEach(helper => {
                scene.remove(helper);
                if (helper.geometry) helper.geometry.dispose();
                if (helper.material) helper.material.dispose();
            });
            checkpointHelpers.length = 0;
            resetPlayer();
            resetTimer();
            checkpoint = 0;
            collidableObjects.forEach(obj => {
                if (obj.mesh.isCheckpointBox) {
                    obj.mesh.visible = true;
                }
            });
        }
        function jump() {
            if (isGrounded) {
                velocity.y = jumpPower;
                isGrounded = false;
                velocity.x = 0;
                velocity.z = 0;
            }
        }
        function startTimer() {
            if (startTime === null) {
                startTime = performance.now();
                elapsedTime = 0; // reset when starting
            }
        }
        function resetTimer() {
            timerStopped = false;
            startTime = null;
            isRecording = true;
            replayRecording = [];
            publicReplayRecording = [];
            if (!testMode) {
                worldEligable = true;
            }
            document.getElementById("timer").innerText = "Time: 0.00s";
            document.getElementById("timer").style.color = "white"; // Change timer color to white
            document.querySelector(".IGT").style.color = "white";
            if (bestTime <= authorTime) {
                document.querySelector(".bestTime").style.color = "green";
            } else if (bestTime <= goldTime) {
                document.querySelector(".bestTime").style.color = "gold";
            } else if (bestTime <= silverTime) {
                document.querySelector(".bestTime").style.color = "silver";
            } else if (bestTime <= bronzeTime) {
                document.querySelector(".bestTime").style.color = "#cd7f32"; // bronze color
            } else {
                document.querySelector(".bestTime").style.color = "white";
            }
            finishedIGT = 0;
            IGT = 0;
            elapsedTime = 0;
        }
        function updateFPS(currentTime) {
            frameCount++;
            const delta = currentTime - lastFrameTime;
            if (testMode) {
                deltaTime = 1; // Fixed 60 FPS step
            } else {
                deltaTime = Math.round((delta / 1000 * 60) * 1000) / 1000;
            }
            fpsTimeAccumulator += delta;
            if (finishedIGT > 0) {
                IGT = finishedIGT;
            } else if (elapsedTime > 0) IGT += delta / 1000;
            document.querySelector(".IGT").innerText = `In Game Time: ${IGT.toFixed(2)}s`;
            if (fpsTimeAccumulator >= fpsUpdateInterval) {
                fps = Math.round((frameCount * 1000) / fpsTimeAccumulator);
                fpsCounter.innerText = `FPS: ${fps}`;
                fpsTimeAccumulator = 0;
                frameCount = 0;
            }
            lastFrameTime = currentTime;
        }
        // world record handling
        nameInput.addEventListener("input", () => {
            const value = nameInput.value;
            const valid = /^[A-Za-z0-9_]*$/;
            if (!valid.test(value)) {
                charCounter.textContent = "Only use letters, numbers, and underscores";
                charCounter.style.color = "red";
            } else {
                const length = value.length;
                charCounter.textContent = `${length} / 20`;
                charCounter.style.color = (length === 20) ? "red" : "white";
            }
        });
        let submitted = false;
        worldRecordMenu.addEventListener("submit", function() {
            document.getElementById("time").value = bestTime;
            document.getElementById("level").value = campaignNumber + "." + campaignLevel;
            document.getElementById("versionNumber").value = versionNumber;
            document.getElementById("replayData").value = btoa(JSON.stringify(replayRecording));
            document.getElementById("publicReplayData").value = btoa(JSON.stringify(publicReplayRecording));
            if (submitted) {
                worldRecordMenu.style.display = "none", playing = true;
            }
        });
        async function getWorldRecord(code) {
            try {
                const response = await fetch(
                    "https://script.google.com/macros/s/AKfycbzQoL-7mvmi8fZS0umv3IfL7bdAZpTQLPUZgKAQ85veqnZkU8dh85eS3klzU78gtvoXmg/exec" +
                    "?level=" + encodeURIComponent(campaignNumber + "." + campaignLevel)
                );
                if (!response.ok) throw new Error("Request failed");
                const contentType = response.headers.get("content-type") || "";
                if (!contentType.includes("application/json")) {
                    const text = await response.text();
                    if (text.includes("No records yet")) {
                        return { status: "no-record", time: null, name: null };
                    } else {
                        throw new Error("Unexpected non-JSON response: " + text);
                    }
                }
                const data = await response.json();
                // ✅ Correct check for missing or invalid data
                if (typeof data.time !== "number" || typeof data.name !== "string") {
                    return { status: "no-record", time: null, name: null };
                }
                return { status: "ok", time: data.time, name: data.name };
            } catch (error) {
                console.error("Error fetching world record:", error);
                return { status: "error", time: null, name: null };
            }
        }
        function triggerGetWorldRecord() {
            const now = Date.now();
            if (now - lastRecordFetchTime - recordFetchCooldown < recordFetchCooldown) return; // too soon
            lastRecordFetchTime = now;
            if (campaignNumber !== null && campaignLevel !== null) {
                getWorldRecord().then(record => {
                    const el = document.getElementById("worldRecord");
                    switch (record.status) {
                        case "ok":
                            el.innerText = `World Record: ${record.time.toFixed(2)} by ${record.name}`;
                            worldRecordTime = record.time;
                            break;
                        case "no-record":
                            el.innerText = "No world record yet.";
                            worldRecordTime = Infinity;
                            break;
                        case "error":
                        default:
                            el.innerText = "Failed to fetch world record.";
                            worldRecordTime = null;
                            break;
                    }
                });
            }
        }
        // Replay recording handling
        function recordFrame() {
            let mask = 0;
            if (keys.space) mask |= 1;
            if (keys.a)     mask |= 2;
            if (keys.d)     mask |= 4;
            if (queuedKeyPresses.r) mask |= 8;
            if (keys.q)     mask |= 16;
            if (keys.e)     mask |= 32;
            replayRecording.push({
                i: mask,
                f: deltaTime || 1
            });
            publicReplayRecording.push([
                +(cameraRig.position.x || 0).toFixed(2),     // x
                +(cameraRig.position.y || 0).toFixed(2),     // y
                +(cameraRig.position.z || 0).toFixed(2),     // z
                +(cameraRig.rotation.y || 0).toFixed(2),     // yaw
                +(camera.rotation.x || 0).toFixed(2),        // pitch
                +(elapsedTime || 0).toFixed(2)               // total time
            ]);
        }
        document.getElementById("replayMenu").addEventListener("submit", function(e) {
            e.preventDefault(); // Prevent actual form submission
            const code = document.getElementById("replayCode").value;
            replayMenu.style.display = "none";
            playing = true;
            handleReplayCode(code); // Your custom logic
        });
        function handleReplayCode(code) {
            let decoded;
            try {
                decoded = atob(code); // decode base64
            } catch (e) {
                console.error("Base64 decoding failed:", e);
                alert("Invalid replay code (not valid base64)");
                return;
            }
            let parsed;
            try {
                parsed = JSON.parse(decoded);
            } catch (e) {
                console.error("JSON parsing failed:", e);
                alert("Invalid replay code (not valid JSON)");
                return;
            }
            if (!Array.isArray(parsed)) {
                alert("Invalid replay code (not an array)");
                return;
            }
            // Check the structure of the first element
            const first = parsed[0];
            if (typeof first === "object" && !Array.isArray(first) && "i" in first && "f" in first) {
                // Input replay
                startReplay(parsed);
            } else if (Array.isArray(first) && first.length >= 6) {
                // Positional replay
                startPublicReplay(parsed);
            } else {
                console.error("Unrecognized frame structure:", first);
            }
        }
        function startReplay(frames) {
            isReplaying = true;
            replayFrames = frames;
            replayIndex = 0;
            replayTimer = 0;
            resetMap();
            playing = true;
        }
        function startPublicReplay(frames) {
            publicReplayFrames = frames;
            publicReplayIndex = 0;
            isPublicReplaying = true;
            resetMap();
            playing = true;
        }
        function decodeInput(mask) {
            return {
                space: !!(mask & 1),
                a:     !!(mask & 2),
                d:     !!(mask & 4),
                r:     !!(mask & 8),
                q:     !!(mask & 16),
                e:     !!(mask & 32)
            };
        }
        // back to normal bhop stuff
        function animate(currentTime) {
            requestAnimationFrame(animate);
            updateFPS(currentTime);
            if (!playing) return;
            if (testMode) {
                testModeReporter.style.display = "block";
            } else {
                testModeReporter.style.display = "none"
            }
            if (showHitbox) {
                playerHitboxReporter.style.display = "block";
            } else {
                playerHitboxReporter.style.display = "none";
            }
            if (practiceMode) {
                practiceModeReporter.style.display = "block";
                worldEligable = false;
            } else {
                practiceModeReporter.style.display = "none";
            }
            if (checkpointHelpers.length > 0) {
                manualCheckpointReporter.style.display = "block";
                manualCheckpointReporter.innerText = `Checkpoints Placed: ${checkpointHelpers.length / 2}`;
            } else {
                manualCheckpointReporter.style.display = "none";
            }
            if (!worldEligable) {
                worldEligableReporter.style.display = "block";
            } else {
                worldEligableReporter.style.display = "none";
            }
            freecamReporter.style.display = freecam ? "block" : "none";
            noclipReporter.style.display = noclip ? "block" : "none";
            if (testMode && !testStep) return; // Pause until testStep is true
            testStep = false; // Reset step flag after allowing one frame
            if (startTime !== null && !timerStopped) {
                if (testMode) {
                    elapsedTime += 1 / 60;
                } else {
                    elapsedTime = (performance.now() - startTime) / 1000;
                }
                document.getElementById("timer").innerText = `Time: ${elapsedTime.toFixed(2)}s`;
            }
            camera.getWorldDirection(direction);
            let previousPosition = cameraRig.position.clone();
            let nextPosition = cameraRig.position.clone();
            if (campaignNumber !== null && campaignLevel !== null) {
                triggerGetWorldRecord();
            }
            if (!freecam && !noclip) {
                positionReporter.innerText = `Position: ${cameraRig.position.x.toFixed(2)}, ${cameraRig.position.y.toFixed(2)}, ${cameraRig.position.z.toFixed(2)}`;
                directionReporter.innerText = `Direction: ${camera.rotation.x.toFixed(2)}, ${cameraRig.rotation.y.toFixed(2)}`;
                // FOR REPLAY
                if (isReplaying && replayIndex < replayFrames.length) {
                    worldEligable = false;
                    let frame = replayFrames[replayIndex];
                    const frameDelta = frame.f || 1; // your normalized deltaTime
                    deltaTime = frameDelta; // Use the frame"s deltaTime
                    replayTimer += deltaTime;
                    while (replayTimer >= frameDelta && replayIndex < replayFrames.length) {
                        replayTimer -= frameDelta;
                        frame = replayFrames[replayIndex];
                        const input = decodeInput(frame.i);
                        keys.space = input.space;
                        keys.a     = input.a;
                        keys.d     = input.d;
                        keys.q     = input.q;
                        keys.e     = input.e;
                        if (input.r) {
                            resetPlayer();
                        }
                        replayIndex++;
                    }
                } else if (isReplaying) {
                    isReplaying = false;
                    playing = false;
                    // Reset input keys
                    keys.space = false;
                    keys.a = false;
                    keys.d = false;
                    keys.r = false;
                    keys.q = false;
                    keys.e = false;
                }
                // FOR PUBLIC REPLAY
                if (isPublicReplaying) {
                    if (publicReplayIndex < publicReplayFrames.length) {
                        worldEligable = false;
                        const frame = publicReplayFrames[publicReplayIndex];
                        if (frame.length >= 6) {
                            const [x, y, z, yaw, pitch, time] = frame;
                            // Set player position and rotation
                            cameraRig.position.set(x, y, z);
                            cameraRig.rotation.y = yaw;
                            camera.rotation.x = pitch;
                            // Override timer (optional)
                            elapsedTime = time;
                            document.getElementById("timer").innerText = `Time: ${elapsedTime.toFixed(2)}s`;
                        }
                        publicReplayIndex++;
                        renderer.render(scene, camera);
                        return;
                    } else {
                        // Stop when done
                        isPublicReplaying = false;
                        playing = false;
                        console.log("Public replay finished.");
                    }
                }
                // DONE
                let forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize(); // normalize AFTER zeroing y
                let worldDown = new THREE.Vector3(0, -1, 0);
                if (keys.a || keys.d) {
                    nextPosition.addScaledVector(forward, speed * deltaTime);
                    if (!isGrounded) {
                        velocity.x = forward.x * speed;
                        velocity.z = forward.z * speed;
                    }
                    if (elapsedTime === 0) startTimer();
                } else if (!isGrounded) {
                    velocity.x = 0;
                    velocity.z = 0;
                }
                if (keys.a) strafeDirection = strafeSpeed;
                else if (keys.d) strafeDirection = -strafeSpeed;
                else strafeDirection = 0;
                if (keys.space) jump();
                const pitchLimit = Math.PI / 2 - 0.05;
                if (keys.e) camera.rotation.x = Math.min(camera.rotation.x + 0.04, pitchLimit);
                if (keys.q) camera.rotation.x = Math.max(camera.rotation.x - 0.04, -pitchLimit);
                velocity.y += gravity * deltaTime;
                nextPosition.y += velocity.y * deltaTime;
                cameraRig.rotation.y += strafeDirection * deltaTime;
                const teleportCooldownTime = 100; // ms
                const collision = checkCollisions(cameraRig.position, nextPosition);
                // Try moving slightly from current position
                let testDown = cameraRig.position.clone();
                let testLeft = cameraRig.position.clone();
                let testForward = cameraRig.position.clone();
                testDown.y -= 0.2; // small downward move
                testLeft.x -= 0.2; // small leftward move
                testDown.z += 0.2; // small forward move
                if (!collision) {
                    cameraRig.position.copy(nextPosition);
                    if (checkCollisions(testDown, testDown) === false) isGrounded = false;
                } else if (collision) {
                    if (velocity.y < 0) {
                        if (performance.now() - lastTeleportTime > teleportCooldownTime) {
                            velocity.y = 0;
                            isGrounded = true;
                        }
                    }
                } else if (collision === "ice") {
                    cameraRig.position = previousPosition;
                        if (checkCollisions(testDown, testDown) === "ice") {
                        // If after moving down we"re still touching ice floor -> it"s floor ice
                        velocity.y = 0;
                        if (checkCollisions(testLeft, testLeft) !== "ice") {
                            cameraRig.position.x += velocity.x;                        }
                            if (checkCollisions(testForward, testForward) !== "ice") {
                            cameraRig.position.z += velocity.z;
                        }
                        isGrounded = true;
                    } else {
                        // Otherwise it"s a wall -> fall down, but allow y movement (slide down)
                        cameraRig.position.y = nextPosition.y;
                        isGrounded = false;
                        if (testLeft === "ice") {
                            velocity.x = 0; // cancel sideways into wall
                        }
                        if (testForward === "ice") {
                            velocity.z = 0; // cancel forward into wall
                        }
                    }
                }
                if (playerBoxHelper) {
                    const playerSize = new THREE.Vector3(1, 2, 1);
                    let box = new THREE.Box3().setFromCenterAndSize(cameraRig.position.clone(), playerSize);
                    playerBoxHelper.box.copy(box);
                }
                if (playerViewLine) {
                    const eyeHeight = 0.8;
                    const eyePos = cameraRig.position.clone().add(new THREE.Vector3(0, eyeHeight, 0));
                    const viewDir = new THREE.Vector3();
                    camera.getWorldDirection(viewDir);
                    const length = 3;                    const endPos = eyePos.clone().add(viewDir.clone().multiplyScalar(length));
                        // Position the cylinder midway between eye and end point                    
                        const mid = eyePos.clone().add(endPos).multiplyScalar(0.5);
                        playerViewLine.position.copy(mid);                    // Orient the cylinder in the direction of viewDir
                        playerViewLine.lookAt(endPos);
                    playerViewLine.rotateX(Math.PI / 2); // because cylinder is vertical by default
                    // Scale the height to match the distance
                    playerViewLine.scale.set(1, length / 2, 1); // y-scale is half-length
                }
                if (nextBoxHelper && sweptBoxHelper) {
                    const playerSize = new THREE.Vector3(1, 2, 1);
                    let nextBox = new THREE.Box3().setFromCenterAndSize(nextPosition.clone(), playerSize);
                    let sweptMin = cameraRig.position.clone().min(nextPosition).sub(playerSize.clone().multiplyScalar(0.5));
                    let sweptMax = cameraRig.position.clone().max(nextPosition).add(playerSize.clone().multiplyScalar(0.5));
                    let sweptBox = new THREE.Box3(sweptMin, sweptMax);
                    nextBoxHelper.box.copy(nextBox);
                    sweptBoxHelper.box.copy(sweptBox);
                }
                if (isRecording) recordFrame();
                queuedKeyPresses.r = false;
            } else {
                // Fly-style camera movement
                camera.getWorldDirection(direction);
                if (keys.w) velocity.addScaledVector(direction, freecamSpeed * deltaTime);
                if (keys.s) velocity.addScaledVector(direction, -freecamSpeed * deltaTime);
                if (keys.a) cameraRig.rotation.y += 0.06;
                if (keys.d) cameraRig.rotation.y -= 0.06;
                if (keys.Shift) velocity.y -= freecamSpeed * deltaTime;
                if (keys.space) velocity.y += freecamSpeed * deltaTime;
                const pitchLimit = Math.PI / 2 - 0.05;
                if (keys.e) camera.rotation.x = Math.min(camera.rotation.x + 0.04, pitchLimit);
                if (keys.q) camera.rotation.x = Math.max(camera.rotation.x - 0.04, -pitchLimit);
                let left = new THREE.Vector3();
                left.crossVectors(camera.up, direction).normalize();
                if (keys.ArrowLeft) velocity.addScaledVector(left, freecamSpeed);
                let right = new THREE.Vector3();
                right.crossVectors(direction, camera.up).normalize();
                if (keys.ArrowRight) velocity.addScaledVector(right, freecamSpeed);
                let upDown = new THREE.Vector3();
                camera.getWorldDirection(direction);
                upDown.crossVectors(left, direction).normalize();
                if (keys.ArrowDown) velocity.addScaledVector(upDown, freecamSpeed);
                if (keys.ArrowUp) velocity.addScaledVector(upDown.clone().negate(), freecamSpeed);
                cameraRig.position.add(velocity);
                if (keys.s || keys.w || keys.ArrowUp || keys.ArrowDown || keys.ArrowRight || keys.ArrowLeft || keys.Shift || keys.space) {
                    velocity.multiplyScalar(1);
                } else {
                    velocity.multiplyScalar(0.8);
                }
            }
            if (elapsedTime > bestTime && document.getElementById("timer").style.color === "white") document.getElementById("timer").style.color = "red";
            if (timer) {
                document.getElementById("timer").style.display = "block"; // Show the timer
                document.querySelector(".bestTime").style.display = "block"; // Show the timer
                // document.querySelector(".IGT").style.display = "block"; // This timer is kinda usless lol
            } else {
                document.getElementById("timer").style.display = "none"; // Show the timer
                document.querySelector(".bestTime").style.display = "none"; // Show the timer
                document.querySelector(".IGT").style.display = "none"; // Show the timer
            };
            if (checkpoints > 0 && timer) {
                document.querySelector(".checkpoint").style.display = "block";
            } else {
                document.querySelector(".checkpoint").style.display = "none";
            };
            document.querySelector(".checkpoint").innerText = `Checkpoint: ${checkpoint.toFixed(0)}/${checkpoints.toFixed(0)}`;
            renderer.render(scene, camera);
        }
    </script>
    <script>
        function scaleUIWrapper() {
            const baseWidth = 1920;
            const baseHeight = 1080;
            const scaleX = window.innerWidth / baseWidth;
            const scaleY = window.innerHeight / baseHeight;
            const scale = Math.min(scaleX, scaleY);
            const wrapper = document.getElementById('ui-scale-wrapper');
            wrapper.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
        window.addEventListener('resize', scaleUIWrapper);
        scaleUIWrapper();
    </script>
</body>
</html>
