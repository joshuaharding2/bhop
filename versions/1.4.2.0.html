<!-- Copyright Â© 2025 Joshua Harding. All rights reserved -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bhop</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Spice&display=swap" rel="stylesheet">
    <style>
        * { padding: 0; margin: 0; box-sizing: border-box; }
        html, body { height: 100%; margin: 0; font-family: sans-serif; line-height: 1; display: flex; justify-content: center; align-items: center; background-color: black; flex-direction: column; }
        button { position: relative; width: 11em; height: 4em; outline: none; transition: 0.3s; background-color: transparent; border: none; font-size: 13px; font-weight: bold; color: #ddebf0; font-family: inherit; margin: 1em 0; }
        #clip { --color: #2761c3; position: absolute; top: 0; overflow: hidden; width: 100%; height: 100%; border: 5px double var(--color); box-shadow: inset 0px 0px 15px #195480; -webkit-clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
        .arrow { position: absolute; transition: 0.2s; background-color: #2761c3; top: 35%; width: 11%; height: 30%; }
        #leftArrow { left: -13.5%; -webkit-clip-path: polygon(100% 0, 100% 100%, 0 50%); clip-path: polygon(100% 0, 100% 100%, 0 50%); }
        #rightArrow { -webkit-clip-path: polygon(100% 49%, 0 0, 0 100%); clip-path: polygon(100% 49%, 0 0, 0 100%); left: 102%; }
        button:hover #rightArrow { background-color: #27c39f; left: -15%; animation: 0.6s ease-in-out both infinite alternate rightArrow8; }
        button:hover #leftArrow { background-color: #27c39f; left: 103%; animation: 0.6s ease-in-out both infinite alternate leftArrow8; }
        .corner { position: absolute; width: 4em; height: 4em; background-color: #2761c3; box-shadow: inset 1px 1px 8px #2781c3; transform: scale(1) rotate(45deg); transition: 0.2s; }
        #rightTop { top: -1.98em; left: 91%; }
        #leftTop { top: -1.96em; left: -3.0em; }
        #leftBottom { top: 2.10em; left: -2.15em; }
        #rightBottom { top: 45%; left: 88%; }
        button:hover #leftTop { animation: 0.1s ease-in-out 0.05s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover #rightTop { animation: 0.1s ease-in-out 0.15s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover #rightBottom { animation: 0.1s ease-in-out 0.25s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover #leftBottom { animation: 0.1s ease-in-out 0.35s both changeColor8, 0.2s linear 0.4s both lightEffect8; }
        button:hover .corner { transform: scale(1.25) rotate(45deg); }
        button:hover #clip { animation: 0.2s ease-in-out 0.55s both greenLight8; --color: #27c39f; }
        @keyframes changeColor8 { from { background-color: #2781c3; } to { background-color: #27c39f; } }
        @keyframes lightEffect8 {from { box-shadow: 1px 1px 5px #27c39f; } to { box-shadow: 0 0 2px #27c39f; } }
        @keyframes greenLight8 { from {} to { box-shadow: inset 0px 0px 32px #27c39f; } }
        @keyframes leftArrow8 { from { transform: translate(0px); } to { transform: translateX(10px); } }
        @keyframes rightArrow8 { from { transform: translate(0px); } to { transform: translateX(-10px); } }
        .btn { display: none; justify-content: center; align-items: center; width: 13rem; overflow: hidden; height: 3rem; margin: 2em; transform: translateY(4em); transition: transform 0.5s; background-size: 300% 300%; cursor: pointer; backdrop-filter: blur(1rem); border-radius: 5rem; transition: 0.5s; animation: gradient_301 5s ease infinite; border: double 4px transparent; background-image: linear-gradient(#212121, #212121), linear-gradient( 137.48deg, #ffdb3b 10%, #fe53bb 45%, #8f51ea 67%, #0044ff 87% ); background-origin: border-box; background-clip: content-box, border-box; }
        #container-stars { position: absolute; margin-top: -2.1em; z-index: -1; width: 100%; height: 100%; overflow: hidden; transition: 114004827s; backdrop-filter: blur(1rem); border-radius: 5rem; }
        strong { z-index: 2; font-family: "Avalors Personal Use"; font-size: 12px; letter-spacing: 5px; color: #ffffff; text-shadow: 0 0 4px white; }
        #glow { position: absolute; display: flex; width: 12rem; }
        .circle { width: 100%; height: 30px; filter: blur(2rem); animation: pulse_3011 4s infinite; z-index: -1; }
        .circle:nth-of-type(1) { background: rgba(254, 83, 186, 0.636); }
        .circle:nth-of-type(2) { background: rgba(142, 81, 234, 0.704); }
        .btn:hover #container-stars { z-index: 1; background-color: #212121; }
        .btn:hover { transform: translateY(4em) scale(1.1); }
        .btn:active { border: double 4px #fe53bb; background-origin: border-box; background-clip: content-box, border-box; animation: none; }
        .btn:active .circle { background: #fe53bb; }
        #stars { position: relative; background: transparent; width: 200rem; height: 200rem; }
        #stars::after { content: ""; position: absolute; top: -10rem; left: -100rem; width: 100%; height: 100%; animation: animStarRotate 90s linear infinite; }
        #stars::after { background-image: radial-gradient(#ffffff 1px, transparent 1%); background-size: 50px 50px; }
        #stars::before { content: ""; position: absolute; top: 0; left: -50%; width: 170%; height: 500%; animation: animStar 60s linear infinite; }
        #stars::before { background-image: radial-gradient(#ffffff 1px, transparent 1%); background-size: 50px 50px; opacity: 0.5; }
        @keyframes animStar { from { transform: translateY(0); } to { transform: translateY(-135rem); } }
        @keyframes animStarRotate { from { transform: rotate(360deg); } to { transform: rotate(0); } } @keyframes gradient_301 { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes pulse_3011 { 0% { transform: scale(0.75); box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.7); } 70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(0, 0, 0, 0); } 100% { transform: scale(0.75); box-shadow: 0 0 0 0 rgba(0, 0, 0, 0); } }
        .levelButton { display: none; transform: translateY(3em); align-items: center; background-image: linear-gradient(144deg, #af40ff, #5b42f3 50%, #00ddeb); border: 0; border-radius: 8px; box-shadow: rgba(151, 65, 252, 0.2) 0 15px 30px -5px; box-sizing: border-box; color: #ffffff; font-size: 18px; justify-content: center; line-height: 1em; max-width: 100%; min-width: 140px; padding: 3px; text-decoration: none; user-select: none; -webkit-user-select: none; touch-action: manipulation; white-space: nowrap; cursor: pointer; transition: all 0.3s; }
        .levelButton:active, .levelButton:hover { outline: 0; }
        .levelButton span { display: flex; align-items: center; justify-content: center; padding: 16px 24px; height: 100%; width: 100%; background-color: rgb(5, 6, 45); border-radius: 6px; transition: 300ms; }
        .levelButton:hover span { background: none; }
        .levelButton:active { transform: translateY(3em) scale(0.9); }
        .campaignRow { display: flex; flex-direction: row; gap: 1em; }
        #startButton { margin-top: 8em; }
        .simpleButton { margin-top: 1.5em; padding: 0.4em 1em; background-color: transparent; color: #27c39f; border: 2px solid #27c39f; border-radius: 8px; font-size: 0.9em; cursor: pointer; transition: 0.5s ease; }
        .timer { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 24px; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .bestTime { position: absolute; top: 54px; left: 50%; transform: translateX(-50%); font-size: 12px; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .IGT { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); font-size: 12px; color: white; background: rgba(0, 0, 0, 0); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .checkpoint { position: absolute; top: 75px; left: 50%; transform: translateX(-50%); font-size: 12px; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        .title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 100px; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: "Bungee Spice", sans-serif; display: block; }
        .times { text-align: right; position: absolute; top: 10px; right: 10px; font-size: 14px; color: white; background: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none;}
        #debugInfoContainer { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 4px; pointer-events: none; z-index: 9999; }
        .debugInfo { font-size: 14px; color: white; background: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 5px; font-family: Arial, sans-serif; display: none; }
        #versionDisplay { position: fixed; bottom: 2px; left: 0px; font-size: 10px; color: white; padding: 5px 10px; border-radius: 5px; font-family: Arial, sans-serif; display: block; }
        #controlsMenu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(20, 20, 20, 0.95); color: white; padding: 2em; border-radius: 10px; font-family: Arial, sans-serif; font-size: 25px; text-align: center; max-width: 90%; width: 600px; z-index: 100; flex-direction: column; justify-content: space-between; }
        #updatesMenu { display: none; position: absolute; top: 0px; left: 50%; transform: translateX(-50%); color: white; padding: 2em; border-radius: 10px; font-family: Arial, sans-serif; font-size: 24px; text-align: center; max-width: 90%; width: 600px; z-index: 100; flex-direction: column; justify-content: space-between; }
    </style>
</head>
<body>
    <div class="title">BHOP</div>
    <div class="timer" id="timer">Time: 0.00s</div>
    <div class="bestTime">Best Time: --.--s</div>
    <div class="IGT">In Game Time: 0.00s</div>
    <div class="checkpoint">Checkpoint: -/-</div>
    <div id="debugInfoContainer">
        <div id="fpsCounter" class="debugInfo">FPS: --</div>
        <div id="positionReporter" class="debugInfo">Position: -, -, -</div>
        <div id="directionReporter" class="debugInfo">Direction: -, -, -</div>
        <div id="practiceModeReporter" class="debugInfo" style="color: yellow;">PRACTICE MODE</div>
        <div id="manualCheckpointReporter" class="debugInfo">Checkpoints Placed: -</div>
        <div id="testModeReporter" class="debugInfo" style="color: yellow;">TEST MODE</div>
        <div id="worldEligableReporter" class="debugInfo" style="color: red;">TIME NOT ELIGABLE FOR WORLD RECORD</div>
        <div id="freecamReporter" class="debugInfo">Freecam</div>
        <div id="noclipReporter" class="debugInfo">Noclip</div>
        <div id="playerHitboxReporter" class="debugInfo">Player hitbox</div>
    </div>
    <div id="versionDisplay">1.4.2.0</div>
    <div id="mapInfo">
        <div id="mapName" class="times">Map: - by -</div>
        <div id="worldRecord" style="top: 30px;" class="times">World Record: --.-- by -</div>
        <div id="authorTime" style="top: 50px;" class="times">Author Record: --.--</div>
        <div id="goldTime" style="top: 70px;" class="times">Gold: --.--</div>
        <div id="silverTime" style="top: 90px;" class="times">Silver: --.--</div>
        <div id="bronzeTime" style="top: 110px;" class="times">Bronze: --.--</div>
    </div>
    <button id="startButton" onclick="playClicked(startButton)">P L A Y<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
    <button id="createButton" onclick="window.location.href=window.location.origin + '/editor'">C R E A T E<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
    <button id="controlsButton" onclick="openMenu('controlsMenu')">C O N T R O L S<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
    <div id="controlsMenu">
        <h2>Controls</h2>
        <ul style="list-style: none; padding: 0; text-align: left; margin-top: 1em;">
            <li><b>a/d</b>: Strafe left and right</li>
            <li><b>q/e</b>: look down and up</li>
            <li><b>Space</b>: Jump</li>
            <li><b>r</b>: Restart</li>
            <li><b>m</b>: Restart map (including checkpoints)</li>
            <li><b>f</b>: Toggle freecam mode</li>
            <li><b>w/s</b>: Move forward and backward (freecam)</li>
            <li><b>a/d</b>: Look left and right (freecam)</li>
            <li><b>q/e</b>: look down and up (freecam)</li>
            <li><b>arrow keys</b>: Move left, right, up, and down (freecam)</li>
            <li><b>Space / Shift</b>: Move up and down based on world not pitch and yaw (freecam)</li>
            <li><b>Escape</b></li>
            <li><b>\</b>: Toggle player hitbox (dev tool)</li>
            <li><b>t (pressed 3 times)</b>: Toggle test mode (dev tool)</li>\
            <li><b>0</b>: Replay menu (not working, and theres no way you're getting a key)</li>
            <li><b>p</b>: Toggle practice mode</li>
            <li><b>f</b>: Noclipd mode replaces freecam in practice (doesn't reset your position after disabling)</li>
            <li><b>c</b>: Place a checkpoint to spawn to (practice mode)</li>
        </ul><button class="simpleButton" onclick="closeMenu('controlsMenu')">Back</button>
    </div>
    <button id="tutorialButton" onclick="playClicked(tutorialButton)">T U T O R I A L<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
    <button id="updatesButton" onclick="openMenu('updatesMenu')">U P D A T E S<div id="clip"><div id="leftTop" class="corner"></div><div id="rightBottom" class="corner"></div><div id="rightTop" class="corner"></div><div id="leftBottom" class="corner"></div></div><span id="rightArrow" class="arrow"></span><span id="leftArrow" class="arrow"></span></button>
    <div id="updatesMenu">
        <h2>What's New? Change log</h2>
        <h3 style="margin-top: 1em;">Minor update 1.4.2.0: 5/17/2025</h3>
        <ul style="text-align: left; margin-top: 1em;">
            <li><b>You should still join the discord server: <a href="https://discord.gg/TcTvmwxgJb" target="_blank">https://discord.gg/TcTvmwxgJb</a></b></li>
            <li><b>Started making pause menu (unfinished)</b></li>
            <li><b>Started developing gameplay replay system (also unfinished)</b></li>
            <li><b>Added a new campaign (player pack 1) with a couple of levels</b>
                <ul style="margin-left: 1.5em; list-style-type: disc;">
                    <li>Challenge 01 (hopefully 02 and 03 comming soon)</li>
                    <li>Tower 01 and Tower 02 (Tower 03?)</li>
                </ul></li>
            <li><b>Added practice mode:</b>
                <ul style="margin-left: 1.5em; list-style-type: disc;">
                    <li>Freecam replaced with noclip in practice that doesn't teleport you back when exiting noclip</li>
                    <li>Can set checkpoints manually by pressing c</li>
                    <li>I did add practice mode reporter and stuff in the top left</li>
                </ul>
            </li>
        </ul>
        <h3 style="margin-top: 1em;">Bug fix: 1.4.1.2: 5/20/2025</h3>
        <ul style="text-align: left; margin-top: 1em;">
            <li><b>Fixed controls menu (idk why it was broken)</b></li>
            <li><b>World Record Names now can only use letters, numbers, and underscores</b></li>
        </ul>
        <h3 style="margin-top: 1em;">Bug fix: 1.4.1.1: 5/17/2025</h3>
        <ul style="text-align: left; margin-top: 1em;">
            <li><b>Fixed killbox floor collisions (much more lenient), now won't kill you if you overlap on normal and kill boxes (as intended)</b></li>
        </ul>
        <h3 style="margin-top: 1em;">Minor update 1.4.1.0: 5/17/2025</h3>
        <ul style="text-align: left; margin-top: 1em;">
            <li><b>I MADE A DISCORD SERVER GO JOIN: <a href="https://discord.gg/TcTvmwxgJb" target="_blank">https://discord.gg/TcTvmwxgJb</a></b></li>
            <li><b>Added teleporters (editor does have them)</b></li>
            <li><b>3 teleporter levels to showcase them in campaign 1</b></li>
            <li><b>Added map name and creator on top right above leaderboard</b></li>
            <li><b>Added game states:</b>
                <ul style="margin-left: 1.5em; list-style-type: disc;">
                    <li>Display on top left of position and direction</li>
                    <li>Player hitbox (used for debugging, press \ to toggle)</li>
                    <li>Test mode (frame by frame, press t three times with less than 1 second inbetween each press) also for debugging</li>
                </ul>
            </li>
            <li><b>Also I fixed container placement on campaign buttons</b></li>
        </ul>
        <h3 style="margin-top: 1em;">Major update 1.4.0.0: 5/06/2025</h3>
        <ul style="text-align: left; margin-top: 1em;">
            <li><b>WORLD RECORDS WORK GO GET EM (at least they should work)</b></li>
            <li><b>I will not be putting myself on the world record leaderboard (I think it would make it less fun for people since i'm really good, and you can already see my best times in the author time section)</b></li>
            <li><b>I've got a lot more content planned and even mostly finished, just unreleased</b></li>
        </ul>
        <button class="simpleButton" onclick="closeMenu('updatesMenu')">
            Back
        </button>
    </div>
    <button id="creditsButton" onclick="openMenu('creditsMenu')">
        C R E D I T S
        <div id="clip">
            <div id="leftTop" class="corner"></div>
            <div id="rightBottom" class="corner"></div>
            <div id="rightTop" class="corner"></div>
            <div id="leftBottom" class="corner"></div>
        </div>
        <span id="rightArrow" class="arrow"></span>
        <span id="leftArrow" class="arrow"></span>
    </button>
    <div id="creditsMenu" style="
        display: none;
        position: absolute;
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        padding: 2em;
        border-radius: 10px;
        font-family: Arial, sans-serif;
        font-size: 25px;
        text-align: center;
        max-width: 90%;
        width: 600px;
        z-index: 100;
        flex-direction: column;
        justify-content: space-between;
    ">
        <h2>Credits</h2>
        <ul style="list-style: none;">
        <li>â </li>
        </ul>
        <h3>Joshua Harding</h3>
        <ul style="list-style: none; padding: 0; text-align: left;">
            <li>â </li>
        </ul>
        <ul style="text-align: left;">
            <li>I made the levels</li>
            <li>Made the movement</li>
            <li>Made all the buttons and ui</li>
            <li>Coded freecam</li>
            <li>Added all different types of boxes</li>
            <li>Fixed and coded editor</li>
            <li>Finished making world records work</li>
            <li>If you couldn't tell, I run the website</li>
            <li>Tell me if theres a bug, i'll fix it</li>
        </ul> 
        <ul style="list-style: none; padding: 0; text-align: left;">
            <li>â </li>
        </ul> 
        <h3>Ben Messer</h3>
        <ul style="list-style: none; padding: 0; text-align: left;">
            <li>â </li>
        </ul>
        <ul style="text-align: left;">
            <li>He inspired the project</li>
            <li>Made the .json level idea</li>
            <li>Came up with editor and started coding it</li>
            <li>I took the freecam movement from one of his projects and altered it</li>
            <li>Advertising</li>
            <li>He started making world records work and made the post function in the apps script, without him I would be lost</li>
        </ul>
        <ul style="list-style: none; padding: 0; text-align: left;">
            <li>â </li>
        </ul> 
        <h3>Liam Reinert</h3>
        <ul style="list-style: none; padding: 0; text-align: left;">
            <li>â </li>
        </ul>
        <ul style="text-align: left;">
            <li>He inspired the project</li>
            <li>Made the .json level idea</li>
            <li>Came up with editor and started coding it</li>
            <li>I took the freecam movement from one of his projects and altered it</li>
            <li>Advertising</li>
            <li>He started making world records work and made the post function in the apps script, without him I would be lost</li>
        </ul>
        <button class="simpleButton" onclick="closeMenu('creditsMenu')">
            Back
        </button>
    </div>
    <button id = "campaign1" type ="button" class="btn" onclick="showCampaign('1')">
        <strong>CAMPAIGN 1</strong>
        <div id="container-stars">
            <div id="stars"></div>
        </div>
        <div id="glow">
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </button>
    <button id = "campaign2" type ="button" class="btn">
        <strong>COMMING SOON</strong>
        <div id="container-stars">
            <div id="stars"></div>
        </div>
        <div id="glow">
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </button>
    <button id = "campaign3" type ="button" class="btn" onclick="showCampaign('3')">
        <strong>PLAYER PACK 1</strong>
        <div id="container-stars">
            <div id="stars"></div>
        </div>
        <div id="glow">
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </button>
    <button id="loadLevel" type="button" class="btn" onclick="startGame('loadLevel')">
        <strong>LOAD CUSTOM LEVEL</strong>
        <div id="container-stars" style="margin-top: -2.8em;">
            <div id="stars"></div>
        </div>
        <div id="glow">
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </button>    
    <div id="campaign0Levels">
        <div class="campaignRow">
            <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 1, startGame()"><span>Open World</span></button>
            <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 2, startGame()"><span>Tunnel</span></button>
            <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 3, startGame()"><span>First Danger</span></button>
        </div>
        <div class="campaignRow">
            <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 4, startGame()"><span>Collect the Yellow!</span></button>
            <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 5, startGame()"><span>Teleporter Intro</span></button>
            <button id="campaign0LevelButton" type="button" class="levelButton" onclick="campaignNumber = 0, campaignLevel = 6, startGame()"><span>Compilation</span></button>
        </div>
    </div>
    <div id="campaign1Levels">
        <div class="campaignRow">
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 1, startGame()"><span>Labyrinth 01</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 2, startGame()"><span>Labyrinth 02</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 3, startGame()"><span>Labyrinth 03</span></button>
        </div>
        <div class="campaignRow">
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 4, startGame()"><span>KillLevel 01</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 5, startGame()"><span>KillLevel 02</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 6, startGame()"><span>KillLevel 03</span></button>
        </div>
        <div class="campaignRow">
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 7, startGame()"><span>CheckpointLevel 01</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 8, startGame()"><span>CheckpointLevel 02</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 9, startGame()"><span>CheckpointLevel 03</span></button>
        </div>
        <div class="campaignRow">
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 91, startGame()"><span>TeleportLevel 01</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 92, startGame()"><span>TeleportLevel 02</span></button>
            <button id="campaign1LevelButton" type="button" class="levelButton" onclick="campaignNumber = 1, campaignLevel = 93, startGame()"><span>TeleportLevel 03</span></button>
        </div>
    </div>
    <div id="campaign3Levels">
        <div class="campaignRow">
            <button id="campaign3LevelButton" type="button" class="levelButton" onclick="campaignNumber = 3, campaignLevel = 1, startGame()"><span>Challenge 01</span></button>
            <button id="campaign3LevelButton" type="button" class="levelButton" onclick="// campaignNumber = 3, campaignLevel = 2, startGame()"><span>Not Available</span></button>
            <button id="campaign3LevelButton" type="button" class="levelButton" onclick="// campaignNumber = 3, campaignLevel = 3, startGame()"><span>Not Available</span></button>
        </div>
        <div class="campaignRow">
            <button id="campaign3LevelButton" type="button" class="levelButton" onclick="campaignNumber = 3, campaignLevel = 4, startGame()"><span>Tower 01</span></button>
            <button id="campaign3LevelButton" type="button" class="levelButton" onclick="campaignNumber = 3, campaignLevel = 5, startGame()"><span>Tower 02</span></button>
            <button id="campaign3LevelButton" type="button" class="levelButton" onclick="// campaignNumber = 3, campaignLevel = 6, startGame()"><span>Not Availible</span></button>
        </div>
    </div>
    <form id="worldRecordMenu" style="
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(20, 20, 20, 0.95);
    color: white;
    padding: 2em;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 25px;
    text-align: center;
    max-width: 90%;
    width: 400px;
    z-index: 100;
    flex-direction: column;
    justify-content: space-between;
    "
    action="https://script.google.com/macros/s/AKfycbwivTcdZ-d7weuXRp4RP6pI5GI0woInnAao3tf6lAm-9zD6gDIBbroW1ekwZv8Bpqa46g/exec" method="post" target="hidden_iframe" onsubmit="submitted=true;">
        <h2 style="margin-top: -0.8em;">World Record!</h2>
        <h4 style="margin-top: 0.2em;">Enter your name</h4>
        <h4 style="margin-top: -0em;">(to be recognized)</h4>
        <label for="name" style="margin-top: 0.5em;">Name:</label>
        <input type="text" id="name" placeholder="type here" maxlength="20" pattern="[A-Za-z0-9_]*" style="
            margin-top: 0.5em;
            color: white;
            padding: 0.4em 1em;
            background-color: transparent;
            border: 2px solid #27c39f;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: 0.5s ease;
        "
        name="name" required><br><br>
        <input type="hidden" id="time" name="time" value="">
        <input type="hidden" id="level" name="level" value="">
        <input type="hidden" id="key" name="key" value="c2VjdXJla2V5X2hleV9mcmllbmQa">
        <input type="hidden" id="replayData" name="replayData" value="">
        <div id="charCounter" style="font-size: 0.8em; color: gray; margin-bottom: 1em; margin-top: -2.5em;">0 / 20</div>
        <input type="submit" class="simpleButton" style="margin-top: 0em;" value="Submit">
        <button class="simpleButton" style="height: 2.2em; width: 13.33333em; margin-top: 0.1em;" onclick="worldRecordMenu.style.display = 'none', playing = true">No Thanks</button>
    </form>
    <form id="replayMenu" autocomplete="off" style="
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(20, 20, 20, 0.95);
        color: white;
        padding: 2em;
        border-radius: 10px;
        font-family: Arial, sans-serif;
        font-size: 25px;
        text-align: center;
        max-width: 90%;
        width: 400px;
        z-index: 100;
        flex-direction: column;
        justify-content: space-between;
    ">
        <h2 style="margin-top: -0.8em;">Watch Replays</h2>
        <label for="replayCode" style="margin-top: 0.5em;">Replay Code:</label>
        <input type="text" id="replayCode" placeholder="paste replay code here" style="
            margin-top: 0.5em;
            color: white;
            padding: 0.4em 1em;
            background-color: transparent;
            border: 2px solid #27c39f;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: 0.5s ease;
        "
        name="replayCode" required><br><br>
        <input type="submit" class="simpleButton" style="margin-top: 0em;" value="Submit">
        <button type="button" class="simpleButton" style="height: 2.2em; width: 13.33333em; margin-top: 0.1em;" onclick="replayMenu.style.display = 'none'; playing = true;">Close</button>
    </form>
    <div id="pauseMenu" style="
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(20, 20, 20, 0.95);
    color: white;
    padding: 2em;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 25px;
    text-align: center;
    max-width: 90%;
    width: 600px;
    z-index: 100;
    flex-direction: column;
    justify-content: space-between;
    ">
        <h1 style="margin-top: -0.5em;">Paused</h1>
        <button class="simpleButton" style="margin-top: 1em; width: 500px;" onclick="playing = true, document.getElementById('pauseMenu').style.display = 'none'">
            <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Resume</span>
        </button>
        <button class="simpleButton" style="margin-top: -0.5em; width: 500px;" onclick="">
            <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Coming Soon</span>
        </button>
        <button class="simpleButton" style="margin-top: -0.5em; width: 500px;" onclick="">
            <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Coming Soon</span>
        </button>
        <button class="simpleButton" style="margin-top: -0.5em; width: 500px;" onclick="location.reload();">
            <span style="display: inline-block; transform: scale(1.5); transform-origin: center;">Exit</span>
        </button>
    </div>
    <iframe name="hidden_iframe" id="hidden_iframe" style="display:none;"></iframe>
    <input type="file" id="fileInput" style="display: none;" accept=".json">
    <script>
        // THREE.js setup
        let scene, camera, renderer;
        let cameraRig;
        let velocity = new THREE.Vector3(0, 0, 0);
        let collidableObjects = [];
        let objectsInScene = [];
        let playerBoxHelper;
        let nextBoxHelper;
        let sweptBoxHelper;
        let playerViewLine;
        let checkpointHelpers = [];
        // UI elements
        let fpsCounter = document.getElementById('fpsCounter');
        let positionReporter = document.getElementById('positionReporter');
        let directionReporter = document.getElementById('directionReporter');
        let practiceModeReporter = document.getElementById('practiceModeReporter');
        let manualCheckpointReporter = document.getElementById('manualCheckpointReporter');
        let testModeReporter = document.getElementById('testModeReporter');
        let worldEligableReporter = document.getElementById('worldEligableReporter');
        let freecamReporter = document.getElementById('freecamReporter');
        let noclipReporter = document.getElementById('noclipReporter');
        let playerHitboxReporter = document.getElementById('playerHitboxReporter');
        let mapInfo = document.getElementById('mapInfo');
        let worldRecordMenu = document.getElementById('worldRecordMenu');
        let nameInput = document.getElementById('name');
        let charCounter = document.getElementById('charCounter');
        let pauseMenu = document.getElementById('pauseMenu');
        // THREE.js movement
        let keys = { w: false, a: false, s: false, d: false, space: false, e: false, q: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false };
        let speed = 0.5;
        let freecamSpeed = 0.05;
        let gravity = -0.01;
        let jumpPower = 0.25;
        let isJumping = false;
        let isGrounded = false;
        let strafeDirection = 0;
        let strafeSpeed = 0.08; // (radians per frame)
        // Storing camera and pos data
        let startPosition = new THREE.Vector3(0, 1, 3.9);
        let radians = 0; // radians refers to the yaw of the cameraRig stored in checkpoint and teleport box data in level files
        let storedVelocity = new THREE.Vector3(0, 0, 0);
        // These are used for freecam - returning player to original state before freecam was activated after it was deactivated
        let storedPosition = new THREE.Vector3(0, 1, 3.9);
        let storedYaw = 0;
        let storedPitch = 0;
        // These are the same but used for manual checkpoints in practice mode
        let storedYaw2 = 0;
        let storedPitch2 = 0;
        let storedVelocity2 = new THREE.Vector3(0, 0, 0);
        // fps stuff
        let fps;
        let lastTeleportTime = 0;
        let lastFrameTime = performance.now();
        let fpsUpdateInterval = 500; // Update every 500ms
        let fpsTimeAccumulator = 0;
        let frameCount = 0;
        let IGT = 0;
        let finishedIGT = 0;
        let deltaTime = 0;
        // special boxes stuff
        let checkpoints = null; // Number of checkpoints
        let checkpoint = null; // Current checkpoint (out of number of checkpoints)
        let lastTeleportedBox = null;
        let destination = null;
        // timer stuff
        let timer = false;
        let startTime = null;
        let timerInterval = null;
        let timerOffset = 0;
        let campaignNumber = null;
        let campaignLevel = null;
        let bestTime = Infinity;
        let mapName = null;
        let mapAuthor = null;
        let worldRecordTime = -Infinity;
        let authorTime = null;
        let goldTime = null;
        let silverTime = null;
        let bronzeTime = null;
        let lastRecordFetchTime = 0;
        let recordFetchCooldown = 3000; // ms
        // game states
        let playing = false;
        let freecam = false;
        let noclip = false;
        let showHitbox = false;
        let testMode = false;
        let testStep = false;
        let tPresses = 0;
        let lastTPressTime = 0;
        let timerStopped = false;
        let worldEligable = true;
        let replayRecording = []; // stores input per frame
        let isRecording = false;  // flag for when to record
        let isReplaying = false;
        let replayFrames = [];
        let replayIndex = 0;
        let replayTimer = 0;
        let practiceMode = false;
        function hideMenuButtons() {
            document.getElementById("startButton").style.display = "none";
            document.getElementById("createButton").style.display = "none";
            document.getElementById("controlsButton").style.display = "none";
            document.getElementById("tutorialButton").style.display = "none";
            document.getElementById("updatesButton").style.display = "none";
            document.getElementById("creditsButton").style.display = "none";
        }
        function showMenuButtons() {
            document.getElementById("startButton").style.display = "block";
            document.getElementById("createButton").style.display = "block";
            document.getElementById("controlsButton").style.display = "block";
            document.getElementById("tutorialButton").style.display = "block";
            document.getElementById("updatesButton").style.display = "block";
            document.getElementById("creditsButton").style.display = "block";
        }
        function openMenu(menuName) {
            hideMenuButtons();
            document.querySelector('.title').style.display = "none";
            const menu = document.getElementById(menuName);
            menu.style.display = "block";
            requestAnimationFrame(() => menu.classList.add("show"));
        }
        function closeMenu(menuName) {
            const menu = document.getElementById(menuName);
            menu.classList.remove("show");
            setTimeout(() => {
                menu.style.display = "none";
                showMenuButtons();
                document.querySelector('.title').style.display = "block";
            }, 300); // matches the CSS transition duration
        }
        function playClicked(button) {
            hideMenuButtons();
            if (button === startButton) {
                showPlayOptions();
            } else if (button === tutorialButton) {
                showCampaign(0);
            }
        }
        function showPlayOptions() {
            document.getElementById("campaign1").style.display = "block";
            document.getElementById("campaign2").style.display = "block";
            document.getElementById("campaign3").style.display = "block";
            document.getElementById("loadLevel").style.display = "block";
        }
        function hidePlayOptions() {
            document.getElementById("campaign1").style.display = "none";
            document.getElementById("campaign2").style.display = "none";
            document.getElementById("campaign3").style.display = "none";
            document.getElementById("loadLevel").style.display = "none";
        }
        function showCampaign(campaignNumber) {
            hidePlayOptions();
            const levelsContainer = document.getElementById("campaign" + campaignNumber + "Levels");
            levelsContainer.style.display = "block";
            const levelButtons = levelsContainer.querySelectorAll(".levelButton");
            levelButtons.forEach(btn => {
                btn.style.display = "flex";
            });
        }
        function hideCampaign(campaignNumber) {
            hidePlayOptions();
            const levelsContainer = document.getElementById("campaign" + campaignNumber + "Levels");
            levelsContainer.style.display = "none";
            const levelButtons = levelsContainer.querySelectorAll(".levelButton");
            levelButtons.forEach(btn => {
                btn.style.display = "none";
            });
        }
        function startGame(initCommand) {
            document.querySelector('.title').style.display = "none";
            hideMenuButtons();
            hidePlayOptions();
            document.body.style.backgroundColor = "transparent"; // Change background to transparent
            fpsCounter.style.display = "block";
            positionReporter.style.display = "block";
            directionReporter.style.display = "block";
            if (initCommand === "loadLevel") {
                init("loadLevel")
            } else {
                hideCampaign(campaignNumber)
                mapInfo.style.display = "block";
                const times = mapInfo.querySelectorAll(".times");
                times.forEach(div => {
                    div.style.display = "flex";
                });
                init();
            }
        }
        function handleFileImport(event) {
            if (!playing) {
                startGame();
            }
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const levelData = JSON.parse(e.target.result);
                clearScene();
                loadLevel(levelData);
            };
            reader.readAsText(file);
        }
        function init(initCommand) {
            if (initCommand === "loadLevel") {
                document.getElementById('fileInput').click();
            }
            if (campaignNumber !== null & campaignLevel !== null) {
                loadLevelFromFile("campaign"+campaignNumber+"."+campaignLevel)
            }
            playing = true;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // camera stays at origin within the rig
            cameraRig = new THREE.Object3D();
            cameraRig.position.copy(startPosition);
            cameraRig.add(camera);
            scene.add(cameraRig);  
            const playerSize = new THREE.Vector3(1, 2, 1);
            let initialBox = new THREE.Box3().setFromCenterAndSize(cameraRig.position.clone(), playerSize);
            playerBoxHelper = new THREE.Box3Helper(initialBox, 0xffa500);
            playerBoxHelper.visible = false;
            scene.add(playerBoxHelper);   
            // Box for next frame position (light blue)
            nextBoxHelper = new THREE.Box3Helper(new THREE.Box3(), 0x00ffff);
            nextBoxHelper.visible = false;
            scene.add(nextBoxHelper);
            // Swept box (orange)
            sweptBoxHelper = new THREE.Box3Helper(new THREE.Box3(), 0xffff00);
            sweptBoxHelper.visible = false;
            scene.add(sweptBoxHelper);
            // Create a red line from eye height to forward direction
            const cylGeom = new THREE.CylinderGeometry(0.025, 0.025, 1, 8, 1, true);
            const cylMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            playerViewLine = new THREE.Mesh(cylGeom, cylMat);
            playerViewLine.visible = false;
            scene.add(playerViewLine);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener("resize", () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
            let hideCursorTimeout;
            // Hide cursor immediately after keypress
            document.addEventListener('keydown', () => {
                document.body.style.cursor = 'none';
            });
            document.addEventListener('mousemove', () => {
                document.body.style.cursor = 'default';
            });
            window.addEventListener("keydown", (event) => {
                if (event.key === "Escape") {
                    if (pauseMenu.style.display === "none") {
                        pauseMenu.style.display = "block";
                        if (!freecam) storedVelocity = velocity.clone();
                        velocity.set(0, 0, 0);
                        playing = false;
                    } else {
                        pauseMenu.style.display = "none";
                        velocity.copy(storedVelocity);
                        if (worldRecordMenu.style.display === "none") playing = true;
                    }
                }
                if (playing) {
                    if (event.key === "\\") {
                        showHitbox = !showHitbox;
                        playerBoxHelper.visible = showHitbox;
                        playerViewLine.visible = showHitbox;
                        nextBoxHelper.visible = showHitbox;
                        sweptBoxHelper.visible = showHitbox;
                    }
                    if (event.key === "t") {
                        const now = performance.now();
                        if (now - lastTPressTime < 1000) {
                            tPresses++;
                        } else {
                            tPresses = 1;
                        }
                        lastTPressTime = now;
                        if (tPresses >= 3) {
                            testMode = !testMode;
                            testStep = false;
                            tPresses = 0;
                            worldEligable = false;
                        }
                    }
                    if (testMode && event.key !== " " && event.key !== "t") {
                        testStep = true;
                    }
                    if (event.key in keys) keys[event.key] = true;
                    if (event.key === " ") keys.space = true;
                    if (event.key === "0") replayMenu.style.display = replayMenu.style.display === "none" ? "flex" : "none";
                    if (event.key === "r") {
                        resetPlayer();
                        if (checkpoint === 0 && checkpointHelpers.length === 0 && !freecam) resetTimer();
                    }
                    if (event.key === "m") {
                        freecam = false;
                        startPosition = new THREE.Vector3(0, 1, 3.9);
                        radians = 0;
                        checkpointHelpers.forEach(helper => {
                            scene.remove(helper);
                            if (helper.geometry) helper.geometry.dispose();
                            if (helper.material) helper.material.dispose();
                        });
                        checkpointHelpers.length = 0;
                        resetPlayer();
                        resetTimer();
                        checkpoint = 0;
                        collidableObjects.forEach(obj => {
                            if (obj.mesh.isCheckpointBox) {
                                obj.mesh.visible = true;
                            }
                        });
                    }
                    if (event.key === "p") {
                        if (!practiceMode) {
                            practiceMode = true;
                            worldEligable = false;
                            noclip = freecam;
                            freecam = false;
                        } else {
                            practiceMode = false;
                            freecam = false;
                            noclip = false;
                            startPosition = new THREE.Vector3(0, 1, 3.9);
                            radians = 0;
                            checkpointHelpers.forEach(helper => {
                                scene.remove(helper);
                                if (helper.geometry) helper.geometry.dispose();
                                if (helper.material) helper.material.dispose();
                            });
                            checkpointHelpers.length = 0;
                            resetPlayer();
                            resetTimer();
                            checkpoint = 0;
                            collidableObjects.forEach(obj => {
                                if (obj.mesh.isCheckpointBox) {
                                    obj.mesh.visible = true;
                                }
                            });
                        }
                    }
                    if (!practiceMode) {
                        if (event.key === "f") {
                            if (!freecam) {
                                storedPosition = startPosition;
                                startPosition = new THREE.Vector3(cameraRig.position.x, cameraRig.position.y, cameraRig.position.z);
                                storedYaw = cameraRig.rotation.y;
                                storedPitch = camera.rotation.x;
                                storedVelocity = velocity.clone();
                                velocity.set(0, 0, 0);
                                freecam = true;
                            } else {
                                isGrounded = false;
                                cameraRig.position.copy(startPosition);
                                velocity.set(0, 0, 0);
                                camera.rotation.set(0, 0, 0);
                                cameraRig.rotation.y = storedYaw;
                                camera.rotation.x = storedPitch;
                                startPosition = storedPosition;
                                velocity.copy(storedVelocity);
                                freecam = false;
                            }
                        }
                    } else {
                        if (event.key === "f") {
                            if (!noclip) {
                                storedPosition = startPosition;
                                startPosition = new THREE.Vector3(cameraRig.position.x, cameraRig.position.y, cameraRig.position.z);
                                storedYaw = cameraRig.rotation.y;
                                storedPitch = camera.rotation.x;
                                storedVelocity = velocity.clone();
                                velocity.set(0, 0, 0);
                                noclip = true;
                            } else {
                                isGrounded = false;
                                noclip = false;
                            }
                        }
                        if (event.key === "c") {
                            startPosition = new THREE.Vector3(cameraRig.position.x, cameraRig.position.y, cameraRig.position.z);
                            storedYaw2 = cameraRig.rotation.y;
                            storedPitch2 = camera.rotation.x;
                            storedVelocity2 = velocity.clone();
                            const checkpointBoxSize = new THREE.Vector3(1, 2, 1);
                            const checkpointBox = new THREE.Box3().setFromCenterAndSize(startPosition.clone(), checkpointBoxSize);
                            const checkpointBoxHelper = new THREE.Box3Helper(checkpointBox, 0xffff00); // Yellow for checkpoint
                            scene.add(checkpointBoxHelper);
                            checkpointHelpers.push(checkpointBoxHelper);
                            const eyeHeight = 0.8;
                            const eyePos = startPosition.clone().add(new THREE.Vector3(0, eyeHeight, 0));
                            const viewDir = new THREE.Vector3();
                            camera.getWorldDirection(viewDir);
                            const length = 3;
                            const endPos = eyePos.clone().add(viewDir.clone().multiplyScalar(length));
                            const mid = eyePos.clone().add(endPos).multiplyScalar(0.5);
                            const geometry = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
                            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                            const checkpointViewLine = new THREE.Mesh(geometry, material);
                            checkpointViewLine.position.copy(mid);
                            checkpointViewLine.lookAt(endPos);
                            checkpointViewLine.rotateX(Math.PI / 2);
                            scene.add(checkpointViewLine);
                            checkpointHelpers.push(checkpointViewLine);
                        }
                    }
                }
            });
            window.addEventListener("keyup", (event) => {
                if (event.key in keys) keys[event.key] = false;
                if (event.key === " ") keys.space = false;
            });
            window.addEventListener("blur", () => {
                for (let key in keys) keys[key] = false;
            });
            document.getElementById('fileInput').addEventListener('change', handleFileImport);
            animate(performance.now());
        }
        function clearScene() {
            objectsInScene.forEach(obj => scene.remove(obj));
            objectsInScene = [];
            collidableObjects = [];
        }
        function loadLevelFromFile(filename) {
            const baseUrl = window.location.origin; // Get the base URL (e.g., https://joshuaharding2.codehs.me)
            const absoluteUrl = `${baseUrl}/${filename}.json`; // Construct the full URL
            fetch(absoluteUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load level file: ${absoluteUrl} (Status: ${response.status})`);
                }
                return response.text(); // Get text first
            })
            .then(text => {
                try {
                    const levelData = JSON.parse(text); // Parse JSON data
                    clearScene();
                    loadLevel(levelData); // Load the level
                } catch (e) {
                    throw e; // Rethrow error for logging
                }
            })
            .catch(error => {
            });
        }
        function loadLevel(levelData) {
            timer = false;
            bestTime = Infinity;
            document.querySelector('.bestTime').innerText = `Best Time: --.--s`;
            checkpoints = 0;
            checkpoint = 0;
            // Handle optional editorData and medal times
            if (levelData[0]?.editorData && campaignNumber != null && campaignLevel != null) {
                const meta = levelData[0];
                // Safe extraction of map info
                mapName = meta.mapName ?? null;
                mapAuthor = meta.mapAuthor ?? null;
                authorTime = meta.authorTime ?? null;
                goldTime = meta.goldTime ?? null;
                silverTime = meta.silverTime ?? null;
                bronzeTime = meta.bronzeTime ?? null;
                if (mapName !== null && mapAuthor !== null) {
                    document.getElementById("mapName").innerText = `Map: ${mapName} by ${mapAuthor}`;
                }
                if (authorTime !== null) {
                    document.getElementById("authorTime").innerText = `Author Record: ${authorTime.toFixed(2)}`;
                }
                if (goldTime !== null) {
                    document.getElementById("goldTime").innerText = `Gold: ${goldTime.toFixed(2)}`;
                }
                if (silverTime !== null) {
                    document.getElementById("silverTime").innerText = `Silver: ${silverTime.toFixed(2)}`;
                }
                if (bronzeTime !== null) {
                    document.getElementById("bronzeTime").innerText = `Bronze: ${bronzeTime.toFixed(2)}`;
                }
            }
            // Load box data (starting from index 1 if editorData was present)
            const startIndex = (levelData[0]?.editorData) ? 1 : 0;
            for (let i = startIndex; i < levelData.length; i++) {
                const box = levelData[i];
                // existing loading logic...
                let width = Math.abs(box.end.x - box.start.x) || 1;
                let height = Math.abs(box.end.y - box.start.y) || 1;
                let depth = Math.abs(box.end.z - box.start.z) || 1;
                let material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                if (box.type === "end") {
                    material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                } else if (box.type === "kill") {
                    material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
                } else if (box.type === "checkpoint") {
                    material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                } else if (box.type === "teleport") {
                    material = new THREE.MeshBasicMaterial({ color: 0xaa00ff, wireframe: true });
                } else if (box.type === "ice") {
                    material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
                }
                let geometry = new THREE.BoxGeometry(width, height, depth);
                let mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (box.start.x + box.end.x) / 2,
                    (box.start.y + box.end.y) / 2,
                    (box.start.z + box.end.z) / 2
                );
                if (box.type === "end") {
                    mesh.isEndBox = true;
                    timer = true;
                }
                if (box.type === "kill") {
                    mesh.isKillBox = true;
                }
                if (box.type === "checkpoint") {
                    mesh.isCheckpointBox = true;
                    checkpoints++;
                    mesh.degrees = box.degrees ?? 0;
                }
                if (box.type === "teleport") {
                    mesh.isTeleportBox = true;
                    mesh.degrees = box.degrees ?? 0;
                    mesh.teleportId = box.teleportId;
                }
                if (box.type === "ice") {
                    mesh.isIceBox = true;
                }
                scene.add(mesh);
                objectsInScene.push(mesh);
                const boundingBox = new THREE.Box3().setFromObject(mesh);
                collidableObjects.push({ mesh: mesh, box: boundingBox });
            }
            freecam = false;
            startPosition = new THREE.Vector3(0, 1, 3.9);
            radians = 0;
            resetPlayer();
            resetTimer();
            checkpoint = 0;
            collidableObjects.forEach(obj => {
                if (obj.mesh.isCheckpointBox) {
                    obj.mesh.visible = true;
                }
            });
        }
        function checkCollisions(prevPosition, nextPosition) {
            const playerSize = new THREE.Vector3(1, 2, 1);
            // Swept box for detecting fast movement collisions
            let sweptMin = prevPosition.clone().min(nextPosition).sub(playerSize.clone().multiplyScalar(0.5));
            let sweptMax = prevPosition.clone().max(nextPosition).add(playerSize.clone().multiplyScalar(0.5));
            let sweptBox = new THREE.Box3(sweptMin, sweptMax);
            // Box at current and next positions
            let currentBox = new THREE.Box3().setFromCenterAndSize(prevPosition, playerSize);
            let nextBox = new THREE.Box3().setFromCenterAndSize(nextPosition, playerSize);
            let collisionDetected = false; // default: no collision
            collidableObjects.forEach(obj => {
                if (!obj.mesh.isEndBox && !obj.mesh.isCheckpointBox && !obj.mesh.isKillBox && !obj.mesh.isTeleportBox && !obj.mesh.isIceBox) {
                    if (sweptBox.intersectsBox(obj.box)) {
                        collisionDetected = true; // normal solid collision
                    }
                } else if (obj.mesh.isKillBox) {
                    // Create a clone of currentBox and shift its bottom edge up very slightly
                    const paddedBox = currentBox.clone();
                    paddedBox.min.y += 0.2; // only affect the bottom
                    if (paddedBox.intersectsBox(obj.box)) {
                        collisionDetected = true;
                        resetPlayer();
                        if (checkpoint === 0) resetTimer();
                    }
                } else if (obj.mesh.isIceBox) {
                    if (sweptBox.intersectsBox(obj.box)) {
                        collisionDetected = "ice"; // ice collision
                    }
                }
            });
            // Check for touching the end box using current position
            collidableObjects.forEach(obj => {
                if (obj.mesh.isEndBox && currentBox.intersectsBox(obj.box)) {
                    if (checkpoint === checkpoints) {
                        timerStopped = true;
                        document.getElementById("timer").style.color = "lime";
                        document.querySelector('.IGT').style.color = "lime";
                        if (!isNaN(IGT) && !isNaN(elapsedTime)) {
                            finishedIGT = Math.min(IGT, elapsedTime);
                        }
                        if (elapsedTime < bestTime) {
                            bestTime = elapsedTime;
                            document.querySelector('.bestTime').innerText = `Best Time: ${bestTime.toFixed(2)}s`;
                            document.querySelector('.bestTime').style.color = "lime";
                            if (bestTime < worldRecordTime && campaignNumber !== null && campaignLevel !== null && worldEligable) worldRecordMenu.style.display = "flex", playing = false;
                            if (bestTime <= authorTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                                document.getElementById("silverTime").style.color = "lime";
                                document.getElementById("goldTime").style.color = "lime";
                                document.getElementById("authorTime").style.color = "lime";
                            } else if (bestTime <= goldTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                                document.getElementById("silverTime").style.color = "lime";
                                document.getElementById("goldTime").style.color = "lime";
                            } else if (bestTime <= silverTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                                document.getElementById("silverTime").style.color = "lime";
                            } else if (bestTime <= bronzeTime) {
                                document.getElementById("bronzeTime").style.color = "lime";
                            }
                        }
                    } else {
                        document.querySelector('.checkpoint').style.color = "red";
                    }
                } else {
                    if (checkpoint === checkpoints) {
                        document.querySelector('.checkpoint').style.color = "lime";
                    } else {
                        document.querySelector('.checkpoint').style.color = "white";
                    }
                }
            });
            // Checkpoint boxes using current position
            collidableObjects.forEach(obj => {
                if (obj.mesh.isCheckpointBox && obj.mesh.visible && currentBox.intersectsBox(obj.box)) {
                    checkpoint++;
                    obj.mesh.visible = false;
                    startPosition = obj.mesh.position;
                    if (obj.mesh.degrees !== undefined) radians = obj.mesh.degrees * Math.PI / 180;
                }
            });
            // Teleport boxes using current position
            collidableObjects.forEach(obj => {
                if (obj.mesh.isTeleportBox && currentBox.intersectsBox(obj.box) && !collisionDetected) {
                    collisionDetected = true;
                    if (obj !== lastTeleportedBox) {
                        handleTeleportCollision(obj, currentBox);
                    }
                } else {
                    destination = null;
                }
            });
            return collisionDetected;
        }
        function handleTeleportCollision(enteredBox, currentBox) {
            const now = performance.now();
            const delta = now - lastTeleportTime;
            if (destination === enteredBox) {
                return;
            }
            if (lastTeleportedBox === enteredBox) {
                return;
            }
            lastTeleportTime = now;
            const enteredId = enteredBox.mesh.teleportId;
            const destinations = collidableObjects.filter(obj =>
                obj.mesh.isTeleportBox &&
                obj.mesh.teleportId == enteredId &&
                obj !== enteredBox
            );
            if (destinations.length > 0) {
                destination = destinations[Math.floor(Math.random() * destinations.length)];
                const targetPos = destination.box.getCenter(new THREE.Vector3());
                const targetRotDeg = destination.mesh.degrees ?? 0;
                const targetRotRad = THREE.MathUtils.degToRad(targetRotDeg);
                // Move player to center of teleport destination
                isGrounded = false;
                cameraRig.position.copy(targetPos);
                cameraRig.rotation.y = targetRotRad;
                // Push the player slightly in the "forward" direction
                const forward = new THREE.Vector3(
                    -Math.sin(targetRotRad),
                    0,
                    -Math.cos(targetRotRad)
                );
                forward.normalize();
                cameraRig.position.addScaledVector(forward, 1); // Push by 1 unit forward
                lastTeleportedBox = enteredBox;
                setTimeout(() => {
                    lastTeleportedBox = null;
                }, 300);
            }
        }
        function resetPlayer() {
            isGrounded = false;
            cameraRig.position.copy(startPosition);
            velocity.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            cameraRig.rotation.y = radians;
            if (checkpointHelpers.length > 0) {
                isGrounded = false;
                velocity.set(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                cameraRig.rotation.y = storedYaw2;
                camera.rotation.x = storedPitch2;
                velocity.copy(storedVelocity2);
            }
        }
        function jump() {
            if (isGrounded) {
                velocity.y = jumpPower;
                isGrounded = false;
                velocity.x = 0;
                velocity.z = 0;
            }
        }
        function startTimer() {
            if (startTime === null) {
                startTime = performance.now();
                elapsedTime = 0; // reset when starting
                isRecording = true;
                replayRecording = [];
            }
        }
        let elapsedTime = 0;  // Declare a variable to store elapsed time
        function resetTimer() {
            timerStopped = false;
            startTime = null;
            if (isRecording) {
                replayRecording = [];
            }
            if (!testMode) {
                worldEligable = true;
            }
            document.getElementById("timer").innerText = "Time: 0.00s";
            document.getElementById("timer").style.color = "white"; // Change timer color to white
            document.querySelector('.IGT').style.color = "white";
            if (bestTime <= authorTime) {
                document.querySelector('.bestTime').style.color = "green";
            } else if (bestTime <= goldTime) {
                document.querySelector('.bestTime').style.color = "gold";
            } else if (bestTime <= silverTime) {
                document.querySelector(".bestTime").style.color = "silver";
            } else if (bestTime <= bronzeTime) {
                document.querySelector(".bestTime").style.color = "#cd7f32"; // bronze color
            } else {
                document.querySelector('.bestTime').style.color = "white";
            }
            finishedIGT = 0;
            IGT = 0;
            elapsedTime = 0;
        }
        function updateFPS(currentTime) {
            frameCount++;
            const delta = currentTime - lastFrameTime;
            if (testMode) {
                deltaTime = 1; // Fixed 60 FPS step
            } else {
                deltaTime = delta / 1000 * 60;
            }
            fpsTimeAccumulator += delta;
            if (finishedIGT > 0) {
                IGT = finishedIGT;
            } else if (elapsedTime > 0) IGT += delta / 1000;
            document.querySelector('.IGT').innerText = `In Game Time: ${IGT.toFixed(2)}s`;
            if (fpsTimeAccumulator >= fpsUpdateInterval) {
                fps = Math.round((frameCount * 1000) / fpsTimeAccumulator);
                fpsCounter.innerText = `FPS: ${fps}`;
                fpsTimeAccumulator = 0;
                frameCount = 0;
            }
            lastFrameTime = currentTime;
        }
        // world record handling
        nameInput.addEventListener('input', () => {
            const value = nameInput.value;
            const valid = /^[A-Za-z0-9_]*$/;
            if (!valid.test(value)) {
                charCounter.textContent = "Only use letters, numbers, and underscores";
                charCounter.style.color = "red";
            } else {
                const length = value.length;
                charCounter.textContent = `${length} / 20`;
                charCounter.style.color = (length === 20) ? "red" : "white";
            }
        });
        let submitted = false;
        worldRecordMenu.addEventListener('submit', function() {
            document.getElementById("time").value = bestTime;
            document.getElementById("level").value = campaignNumber + "." + campaignLevel;
            document.getElementById("replayData").value = btoa(JSON.stringify(replayRecording));
            if (submitted) {
                worldRecordMenu.style.display = "none", playing = true;
            }
        });
        async function getWorldRecord(code) {
            try {
                const response = await fetch(
                    'https://script.google.com/macros/s/AKfycbwivTcdZ-d7weuXRp4RP6pI5GI0woInnAao3tf6lAm-9zD6gDIBbroW1ekwZv8Bpqa46g/exec' +
                    '?level=' + encodeURIComponent(campaignNumber + "." + campaignLevel)
                );
                if (!response.ok) throw new Error('Request failed');
                const contentType = response.headers.get('content-type') || '';
                if (!contentType.includes('application/json')) {
                    const text = await response.text();
                    if (text.includes('No records yet')) {
                        return { status: "no-record", time: null, name: null };
                    } else {
                        throw new Error('Unexpected non-JSON response: ' + text);
                    }
                }
                const data = await response.json();
                // â Correct check for missing or invalid data
                if (typeof data.time !== 'number' || typeof data.name !== 'string') {
                    return { status: "no-record", time: null, name: null };
                }
                return { status: "ok", time: data.time, name: data.name };
            } catch (error) {
                console.log('Error fetching world record:', error);
                return { status: "error", time: null, name: null };
            }
        }
        function triggerGetWorldRecord() {
            const now = Date.now();
            if (now - lastRecordFetchTime - recordFetchCooldown < recordFetchCooldown) return; // too soon
            lastRecordFetchTime = now;
            if (campaignNumber !== null && campaignLevel !== null) {
                getWorldRecord().then(record => {
                    const el = document.getElementById("worldRecord");
                    switch (record.status) {
                        case "ok":
                            el.innerText = `World Record: ${record.time.toFixed(2)} by ${record.name}`;
                            worldRecordTime = record.time;
                            break;
                        case "no-record":
                            el.innerText = "No world record yet.";
                            worldRecordTime = Infinity;
                            break;
                        case "error":
                        default:
                            el.innerText = "Failed to fetch world record.";
                            worldRecordTime = null;
                            break;
                    }
                });
            }
        }
        // Replay recording handling
        function recordFrame() {
            let mask = 0;
            if (keys.space) mask |= 1;
            if (keys.a)     mask |= 2;
            if (keys.d)     mask |= 4;
            if (keys.r)     mask |= 8;
            if (keys.q)     mask |= 16;
            if (keys.e)     mask |= 32;
            replayRecording.push({
                i: mask,
                f: fps || 60 // fallback in case fps hasn't been calculated yet
            });
        }
        document.getElementById("replayMenu").addEventListener("submit", function(e) {
            e.preventDefault(); // Prevent actual form submission
            const code = document.getElementById("replayCode").value;
            replayMenu.style.display = "none";
            playing = true;
            handleReplayCode(code); // Your custom logic
        });
        function handleReplayCode(code) {
            let decoded;
            try {
                console.log("Length of base64 string:", code.length);
                console.log("First 50 chars:", code.slice(0, 50));
                console.log("Last 50 chars:", code.slice(-50));
                const json = atob(code); // base64 decode
                decoded = JSON.parse(json);
            } catch (err) {
                console.error("Invalid replay code (base64 or JSON failed):", err);
                return;
            }
            startReplay(decoded);
        }
        function startReplay(frames) {
            isReplaying = true;
            replayFrames = frames;
            replayIndex = 0;
            replayTimer = 0;
            resetPlayer();
            resetTimer();
            playing = true;
            console.log("Starting replay with", frames.length, "frames.");
        }
        function decodeInput(mask) {
            return {
                space: !!(mask & 1),
                a:     !!(mask & 2),
                d:     !!(mask & 4),
                r:     !!(mask & 8),
                q:     !!(mask & 16),
                e:     !!(mask & 32)
            };
        }
        // back to normal bhop stuff
        function animate(currentTime) {
            requestAnimationFrame(animate);
            updateFPS(currentTime);
            if (!playing) return;
            if (testMode) {
                testModeReporter.style.display = "block";
            } else {
                testModeReporter.style.display = "none"
            }
            if (showHitbox) {
                playerHitboxReporter.style.display = "block";
            } else {
                playerHitboxReporter.style.display = "none";
            }
            if (practiceMode) {
                practiceModeReporter.style.display = "block";
                worldEligable = false;
            } else {
                practiceModeReporter.style.display = "none";
            }
            if (checkpointHelpers.length > 0) {
                manualCheckpointReporter.style.display = "block";
                manualCheckpointReporter.innerText = `Checkpoints Placed: ${checkpointHelpers.length / 2}`;
            } else {
                manualCheckpointReporter.style.display = "none";
            }
            if (!worldEligable) {
                worldEligableReporter.style.display = "block";
            } else {
                worldEligableReporter.style.display = "none";
            }
            freecamReporter.style.display = freecam ? "block" : "none";
            noclipReporter.style.display = noclip ? "block" : "none";
            if (testMode && !testStep) return; // Pause until testStep is true
            testStep = false; // Reset step flag after allowing one frame
            if (startTime !== null && !timerStopped) {
                if (testMode) {
                    elapsedTime += 1 / 60;
                } else {
                    elapsedTime = (performance.now() - startTime) / 1000;
                }
                document.getElementById("timer").innerText = `Time: ${elapsedTime.toFixed(2)}s`;
            }
            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            let previousPosition = cameraRig.position.clone();
            let nextPosition = cameraRig.position.clone();
            if (campaignNumber !== null && campaignLevel !== null) {
                triggerGetWorldRecord();
            }
            if (!freecam && !noclip) {
                positionReporter.innerText = `Position: ${cameraRig.position.x.toFixed(2)}, ${cameraRig.position.y.toFixed(2)}, ${cameraRig.position.z.toFixed(2)}`;
                directionReporter.innerText = `Direction: ${direction.x.toFixed(2)}, ${direction.y.toFixed(2)}, ${direction.z.toFixed(2)}`;
                // FOR REPLAY
                if (isReplaying && replayIndex < replayFrames.length) {
                    const frame = replayFrames[replayIndex];
                    const targetDelta = 1 / frame.f;
                    replayTimer += targetDelta;
                    while (replayTimer >= targetDelta && replayIndex < replayFrames.length) {
                        replayTimer -= targetDelta;
                        const frame = replayFrames[replayIndex];
                        const input = decodeInput(frame.i);
                        keys.space = input.space;
                        keys.a = input.a;
                        keys.d = input.d;
                        keys.r = input.r;
                        keys.q = input.q;
                        keys.e = input.e;
                        console.log("Replay frame:", replayIndex);
                        replayIndex++;
                    }
                } else if (isReplaying) {
                    isReplaying = false;
                    // Reset input keys
                    keys.space = false;
                    keys.a = false;
                    keys.d = false;
                    keys.r = false;
                    keys.q = false;
                    keys.e = false;
                    console.log("Replay finished.");
                }
                // DONE
                let forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize(); // normalize AFTER zeroing y
                let worldDown = new THREE.Vector3(0, -1, 0);
                if (keys.a || keys.d) {
                    nextPosition.addScaledVector(forward, speed * deltaTime);
                    if (!isGrounded) {
                        velocity.x = forward.x * speed;
                        velocity.z = forward.z * speed;
                    }
                    if (elapsedTime === 0) startTimer();
                } else if (!isGrounded) {
                    velocity.x = 0;
                    velocity.z = 0;
                }
                if (keys.a) strafeDirection = strafeSpeed;
                else if (keys.d) strafeDirection = -strafeSpeed;
                else strafeDirection = 0;
                if (keys.space) jump();
                const pitchLimit = Math.PI / 2 - 0.05;
                if (keys.e) camera.rotation.x = Math.min(camera.rotation.x + 0.04, pitchLimit);
                if (keys.q) camera.rotation.x = Math.max(camera.rotation.x - 0.04, -pitchLimit);
                velocity.y += gravity * deltaTime;
                nextPosition.y += velocity.y * deltaTime;
                cameraRig.rotation.y += strafeDirection * deltaTime;
                const teleportCooldownTime = 100; // ms
                const collision = checkCollisions(cameraRig.position, nextPosition);
                // Try moving slightly from current position
                let testDown = cameraRig.position.clone();
                let testLeft = cameraRig.position.clone();
                let testForward = cameraRig.position.clone();
                testDown.y -= 0.2; // small downward move
                testLeft.x -= 0.2; // small leftward move
                testDown.z += 0.2; // small forward move
                if (!collision) {
                    cameraRig.position.copy(nextPosition);
                    if (checkCollisions(testDown, testDown) === false) isGrounded = false;
                } else if (collision) {
                    if (velocity.y < 0) {
                        if (performance.now() - lastTeleportTime > teleportCooldownTime) {
                            velocity.y = 0;
                            isGrounded = true;
                        }
                    }
                } else if (collision === "ice") {
                    cameraRig.position = previousPosition;
                        if (checkCollisions(testDown, testDown) === "ice") {
                        // If after moving down we're still touching ice floor -> it's floor ice
                        velocity.y = 0;
                        if (checkCollisions(testLeft, testLeft) !== "ice") {
                            cameraRig.position.x += velocity.x;                        }
                            if (checkCollisions(testForward, testForward) !== "ice") {
                            cameraRig.position.z += velocity.z;
                        }
                        isGrounded = true;
                    } else {
                        // Otherwise it's a wall -> fall down, but allow y movement (slide down)
                        cameraRig.position.y = nextPosition.y;
                        isGrounded = false;
                        if (testLeft === "ice") {
                            velocity.x = 0; // cancel sideways into wall
                        }
                        if (testForward === "ice") {
                            velocity.z = 0; // cancel forward into wall
                        }
                    }
                }
                if (playerBoxHelper) {
                    const playerSize = new THREE.Vector3(1, 2, 1);
                    let box = new THREE.Box3().setFromCenterAndSize(cameraRig.position.clone(), playerSize);
                    playerBoxHelper.box.copy(box);
                }
                if (playerViewLine) {
                    const eyeHeight = 0.8;
                    const eyePos = cameraRig.position.clone().add(new THREE.Vector3(0, eyeHeight, 0));
                    const viewDir = new THREE.Vector3();
                    camera.getWorldDirection(viewDir);
                    const length = 3;                    const endPos = eyePos.clone().add(viewDir.clone().multiplyScalar(length));
                        // Position the cylinder midway between eye and end point                    
                        const mid = eyePos.clone().add(endPos).multiplyScalar(0.5);
                        playerViewLine.position.copy(mid);                    // Orient the cylinder in the direction of viewDir
                        playerViewLine.lookAt(endPos);
                    playerViewLine.rotateX(Math.PI / 2); // because cylinder is vertical by default
                    // Scale the height to match the distance
                    playerViewLine.scale.set(1, length / 2, 1); // y-scale is half-length
                }
                if (nextBoxHelper && sweptBoxHelper) {
                    const playerSize = new THREE.Vector3(1, 2, 1);
                    let nextBox = new THREE.Box3().setFromCenterAndSize(nextPosition.clone(), playerSize);
                    let sweptMin = cameraRig.position.clone().min(nextPosition).sub(playerSize.clone().multiplyScalar(0.5));
                    let sweptMax = cameraRig.position.clone().max(nextPosition).add(playerSize.clone().multiplyScalar(0.5));
                    let sweptBox = new THREE.Box3(sweptMin, sweptMax);
                    nextBoxHelper.box.copy(nextBox);
                    sweptBoxHelper.box.copy(sweptBox);
                }
                if (isRecording) recordFrame();
            } else {
                // Fly-style camera movement
                let direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                if (keys.w) velocity.addScaledVector(direction, freecamSpeed * deltaTime);
                if (keys.s) velocity.addScaledVector(direction, -freecamSpeed * deltaTime);
                if (keys.a) cameraRig.rotation.y += 0.06;
                if (keys.d) cameraRig.rotation.y -= 0.06;
                if (keys.Shift) velocity.y -= freecamSpeed * deltaTime;
                if (keys.space) velocity.y += freecamSpeed * deltaTime;
                const pitchLimit = Math.PI / 2 - 0.05;
                if (keys.e) camera.rotation.x = Math.min(camera.rotation.x + 0.04, pitchLimit);
                if (keys.q) camera.rotation.x = Math.max(camera.rotation.x - 0.04, -pitchLimit);
                let left = new THREE.Vector3();
                left.crossVectors(camera.up, direction).normalize();
                if (keys.ArrowLeft) velocity.addScaledVector(left, freecamSpeed);
                let right = new THREE.Vector3();
                right.crossVectors(direction, camera.up).normalize();
                if (keys.ArrowRight) velocity.addScaledVector(right, freecamSpeed);
                let upDown = new THREE.Vector3();
                camera.getWorldDirection(direction);
                upDown.crossVectors(left, direction).normalize();
                if (keys.ArrowDown) velocity.addScaledVector(upDown, freecamSpeed);
                if (keys.ArrowUp) velocity.addScaledVector(upDown.clone().negate(), freecamSpeed);
                cameraRig.position.add(velocity);
                if (keys.s || keys.w || keys.ArrowUp || keys.ArrowDown || keys.ArrowRight || keys.ArrowLeft || keys.Shift || keys.space) {
                    velocity.multiplyScalar(1);
                } else {
                    velocity.multiplyScalar(0.8);
                }
            }
            if (elapsedTime > bestTime && document.getElementById("timer").style.color === "white") document.getElementById("timer").style.color = "red";
            if (timer) {
                document.getElementById("timer").style.display = "block"; // Show the timer
                document.querySelector('.bestTime').style.display = 'block'; // Show the timer
                // document.querySelector('.IGT').style.display = 'block'; // This timer is kinda usless lol
            } else {
                document.getElementById("timer").style.display = "none"; // Show the timer
                document.querySelector('.bestTime').style.display = 'none'; // Show the timer
                document.querySelector('.IGT').style.display = 'none'; // Show the timer
            };
            if (checkpoints > 0 && timer) {
                document.querySelector('.checkpoint').style.display = 'block';
            } else {
                document.querySelector('.checkpoint').style.display = 'none';
            };
            document.querySelector('.checkpoint').innerText = `Checkpoint: ${checkpoint.toFixed(0)}/${checkpoints.toFixed(0)}`;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>a
